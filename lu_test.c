/*! –ú–Ω–æ–≥–æ —á–∏—Å–ª–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü –∏ —Ä–µ—à–µ–Ω–∏—è –°–õ–ê–£ 
	—Å–º LINALG.md
	
	¬ß¬≤¬∞‚Äñ‚â°‚â†‚âà‚àÇ‚àÜ·µÄ·¥¥
 */

/*! LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü –∏ —Ä–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º –°–õ–ê–£ –º–µ—Ç–æ–¥–æ–º LU
–ú–µ—Ç–æ–¥—ã –≤—ã—á–∏—Å–ª–µ–Ω–∏—è LU-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è:
‚Ä¢ –º–µ—Ç–æ–¥ –ì–∞—É—Å—Å–∞;
(–Ω–∏–∑–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å –¥–ª—è —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü, –±–æ–ª—å—à–æ–π –æ–±—ä–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏–π)
‚Ä¢ –∞–ª–≥–æ—Ä–∏—Ç–º –î—É–ª–∏—Ç—Ç–ª–∞;
(L - —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è, U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è)
‚Ä¢ –∞–ª–≥–æ—Ä–∏—Ç–º –ö—Ä–æ—É—Ç–∞.
(L - –Ω–∏–∂–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è, U - —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è)

LUP-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ (LUP-–¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è) ‚Äî –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã 
ùê¥ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è ùëÉùê¥=ùêøùëà –≥–¥–µ –º–∞—Ç—Ä–∏—Ü–∞ 
ùêø —è–≤–ª—è–µ—Ç—Å—è –Ω–∏–∂–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π —Å –µ–¥–∏–Ω–∏—Ü–∞–º–∏ –Ω–∞ –≥–ª–∞–≤–Ω–æ–π –¥–∏–∞–≥–æ–Ω–∞–ª–∏, 
ùëà ‚Äî –≤–µ—Ä—Ö–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –æ–±—â–µ–≥–æ –≤–∏–¥–∞, –∞ ùëÉ ‚Äî —Ç. –Ω. –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫, 
–ø–æ–ª—É—á–∞–µ–º–∞—è –∏–∑ –µ–¥–∏–Ω–∏—á–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –ø—É—Ç—ë–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—Ç—Ä–æ–∫ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü–æ–≤. 

LUP-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ —ç—Ç–æ LU-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã A —Å —á–∞—Å—Ç–∏—á–Ω—ã–º –≤—ã–±–æ—Ä–æ–º –≤–µ–¥—É—â–µ–≥–æ
—ç–ª–µ–º–µ–Ω—Ç–∞ (–ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ —Å—Ç—Ä–æ–∫–∞–º), –∫–æ—Ç–æ—Ä–æ–µ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:
P A = L U ,
–∞, –≤ —Å–ª—É—á–∞–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º LUP-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –≤ –≤–∏–¥–µ:
A Q = L U ,
–∞, –≤ –Ω–∞–∏–±–æ–ª–µ–µ –æ–±—â–µ–º –≤–∏–¥–µ:
P A Q = L U ,
–≥–¥–µ:
P - –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –ø–æ —Å—Ç—Ä–æ–∫–∞–º;
Q - –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º;
L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.

LDU-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —Ç—Ä–µ—Ö
–º–∞—Ç—Ä–∏—Ü:
A = L D U ,
–≥–¥–µ:
D - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
U - –≤–µ—Ä—Ö–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.

LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ (–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ)
LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤
–≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π –¥–≤—É—Ö –º–∞—Ç—Ä–∏—Ü:
A = L L‚É∞
A = U‚É∞U
–≥–¥–µ:
L - –Ω–∏–∂–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞; U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.
–î–ª—è –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü: L‚É∞ = L·µÄ –∏ U‚É∞ = U·µÄ.

## QR - —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã

QR - —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã ‚Äî –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —É–Ω–∏—Ç–∞—Ä–Ω–æ–π 
(–∏–ª–∏ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã) –∏ –≤–µ—Ä—Ö–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã. QR-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è 
–æ—Å–Ω–æ–≤–æ–π –æ–¥–Ω–æ–≥–æ –∏–∑ –º–µ—Ç–æ–¥–æ–≤ –ø–æ–∏—Å–∫–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ —á–∏—Å–µ–ª –º–∞—Ç—Ä–∏—Ü—ã ‚Äî QR-–∞–ª–≥–æ—Ä–∏—Ç–º–∞

–ü–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤

	–ü—Ä–æ—Ü–µ—Å—Å –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞
–ü—Ä–æ—Ü–µ—Å—Å –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞‚Ää‚Äî‚Ää—ç—Ç–æ –º–µ—Ç–æ–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã Q, –∫–æ—Ç–æ—Ä–∞—è —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã—Ö –∏–ª–∏ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö –µ–¥–∏–Ω–∏—á–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ –∑–∞–Ω–∏–º–∞–µ—Ç —Ç–∞–∫–æ–µ –∂–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ, —á—Ç–æ –∏ –º–∞—Ç—Ä–∏—Ü–∞ X.

1. –í—ã–±—Ä–∞—Ç—å –≤–µ–∫—Ç–æ—Ä —Å—Ç–æ–ª–±–µ—Ü u_1 = x_1, x1!=0
2. –†–∞—Å—á–∏—Ç–∞—Ç—å –¥–ª—è –≤—Å–µ—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ u_k = x_k - sum_{j=1}^{k-1} proj(u_j, x_k)
3. –î–ª—è –≤—Å–µ—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ Q_k = u_k/ norm(u_k) -- –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è

proj - —Å—á–∏—Ç–∞–µ—Ç –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–π –≤–µ–∫—Ç–æ—Ä u_k –∫ –¥—Ä—É–≥–∏–º –º–µ—Ç–æ–¥–æ–º –Ω–∞–π—Ç–∏ —Ç–∞–∫—É—é –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É —á—Ç–æ–±—ã u_2 = x_2 - c u_2

QR = X
R = Q^-1 X = Q^T X

https://www-users.cse.umn.edu/~olver/aims_/qr.pdf


–ü—Ä–æ—Ü–µ—Å—Å –ì—Ä–∞–º–∞ ‚Äï –®–º–∏–¥—Ç–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å—Ç–æ–ª–∫–æ–≤–∞–Ω –∫–∞–∫ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –Ω–µ–≤—ã—Ä–æ–∂–¥–µ–Ω–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –≤ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π (–∏–ª–∏ —É–Ω–∏—Ç–∞—Ä–Ω–æ–π –≤ —Å–ª—É—á–∞–µ —ç—Ä–º–∏—Ç–æ–≤–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞) –∏ –≤–µ—Ä—Ö–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã —Å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º–∏ –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ ‚Äï QR-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ

### –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã

–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —Ç—Ä–µ—Ö –º–∞—Ç—Ä–∏—Ü:
A = V Œõ V^{‚àí1},
–≥–¥–µ:
V - –º–∞—Ç—Ä–∏—Ü–∞ —Å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –≤–µ–∫—Ç–æ—Ä–∞–º–∏ –º–∞—Ç—Ä–∏—Ü—ã A;
Œõ - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ ùúÜ(A).
–¢–æ–ª—å–∫–æ –º–∞—Ç—Ä–∏—Ü—ã, –∏–º–µ—é—â–∏–µ –ø–æ–ª–Ω—ã–π –Ω–∞–±–æ—Ä —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤ –≤–∏–¥–µ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è.

###–ö–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ –ñ–æ—Ä–¥–∞–Ω–∞

–ö–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º–∞ –ñ–æ—Ä–¥–∞–Ω–∞ - —ç—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A –≤ –≤–∏–¥–µ:
A = C J C^{‚àí1},
–≥–¥–µ:
C - –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –Ω–æ–≤–æ–º—É –±–∞–∑–∏—Å—É;
J - –º–∞—Ç—Ä–∏—Ü–∞ –ñ–æ—Ä–¥–∞–Ω–∞.
–ü–æ —Å—É—Ç–∏, —ç—Ç–æ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ - –æ–±–æ–±—â–µ–Ω–∏–µ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –Ω–∞ —Å–ª—É—á–∞–π –∫—Ä–∞—Ç–Ω—ã—Ö —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π.
–ï—Å–ª–∏ –∫—Ä–∞—Ç–Ω–æ—Å—Ç—å –≤—Å–µ—Ö —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –º–∞—Ç—Ä–∏—Ü—ã A —Ä–∞–≤–Ω–∞ –µ–¥–∏–Ω–∏—Ü–µ, —Ç–æ –º–∞—Ç—Ä–∏—Ü–∞
J - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –º–∞—Ç—Ä–∏—Ü–∞ J —è–≤–ª—è–µ—Ç—Å—è –±–ª–æ–∫-–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π –∏
—Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –ñ–æ—Ä–¥–∞–Ω–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤.

### –†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –®—É—Ä–∞

–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –®—É—Ä–∞ –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —Ç—Ä–µ—Ö –º–∞—Ç—Ä–∏—Ü:
A = U T U*,
–≥–¥–µ:
U - —É–Ω–∏—Ç–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
U*- —ç—Ä–º–∏—Ç–æ–≤–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
T - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å Tii = ùúÜi(A).
–î–ª—è —Å–ª—É—á–∞—è –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –∏–º–µ–µ—Ç –≤–∏–¥:
A = V T V^‚ä§ ,
–≥–¥–µ:
V - –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.

### –£–Ω–∏—Ç–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞

–£–Ω–∏—Ç–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ - —ç—Ç–æ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –≤ –æ–±—â–µ–º —Å–ª—É—á–∞–µ —Å–æ—Å—Ç–æ—è—â–∞—è –∏–∑
–∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —á–∏—Å–µ–ª, –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞ —ç—Ä–º–∏—Ç–æ–≤–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É
—Ä–∞–≤–Ω–æ –µ–¥–∏–Ω–∏—á–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ, —Ç.–µ.:
U‚É∞U = U U‚É∞ = I

### –û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞

–û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ - —ç—Ç–æ —É–Ω–∏—Ç–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –Ω–æ —Ç–æ–ª—å–∫–æ —Å –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏
—á–∏—Å–ª–∞–º–∏, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–π —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ:
A·µÄ A = A A·µÄ = I ,
–∏ –∫–∞–∫ —Å–ª–µ–¥—Å—Ç–≤–∏–µ:
A·µÄ = A^{‚àí1}

### –≠—Ä–º–∏—Ç–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞
–≠—Ä–º–∏—Ç–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞ - —ç—Ç–æ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –≤ –æ–±—â–µ–º —Å–ª—É—á–∞–µ —Å–æ—Å—Ç–æ—è—â–∞—è –∏–∑ 
–∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —á–∏—Å–µ–ª, –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–≤–Ω–∞ —Å–≤–æ–µ–π —ç—Ä–º–∏—Ç–æ–≤–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–æ–π (—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–æ-
—Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ) –∏ —Ä–∞–≤–Ω–∞ —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–æ–π
–º–∞—Ç—Ä–∏—Ü–µ, —Ç.–µ.:
A = (A¬Ø)·µÄ = A‚É∞,
A‚É∞ -- —ç—Ç–æ –∏ —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ —Å–æ–ø—Ä—è–∂–µ–Ω–∏–µ

	det(A·µÄ)= det(A) 
	det(A)=det(LU)=det(L)det(U)

–û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å, –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–π det –º–µ—Ä–∞ –º–∞—Å—à—Ç–∞–±–Ω–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è, 
–æ–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –º–∞—Ç—Ä–∏—Ü–µ–π. –ö–æ–≥–¥–∞ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –Ω–∏–∂–µ –Ω—É–ª—è, –º–∞—Ç—Ä–∏—Ü–∞ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∞, –∏ –Ω–∏–∫–∞–∫–∞—è –∏–Ω–≤–µ—Ä—Å–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
–û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã - –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. 


–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –º–∞—Ç—Ä–∏—Ü—ã –ø–æ—á—Ç–∏ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ã, –∏ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –æ–±—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, 
–≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤–æ—Å–ø—Ä–∏–∏–º—á–∏–≤–æ –∫ —á–∏—Å–ª–æ–≤—ã–º –æ—à–∏–±–∫–∞–º. cond —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª—è–µ—Ç —á–∏—Å–ª–æ –æ–±—É—Å–ª–æ–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏ 
–¥–ª—è –∏–Ω–≤–µ—Ä—Å–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –¥–∞–µ—Ç –∏–Ω–¥–∏–∫–∞—Ü–∏—é –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–æ—á–Ω–æ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –º–∞—Ç—Ä–∏—á–Ω–æ–π –∏–Ω–≤–µ—Ä—Å–∏–∏. 
–ß–∏—Å–ª–æ –æ–±—É—Å–ª–æ–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏ –ª–µ–∂–∏—Ç –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 1 –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ —É—Å—Ç–æ–π—á–∏–≤–æ–π –º–∞—Ç—Ä–∏—Ü—ã –∫ Inf –¥–ª—è 
—Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã.

c = cond(A)

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–∏–Ω–æ—Ä

–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–∏–Ω–æ—Ä M¬Ø_ij –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å, 
—Å–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã A –ø—É—Ç–µ–º —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ –∏ —Å—Ç–æ–ª–±—Ü–æ–≤ c –Ω–æ–º–µ—Ä–∞–º–∏ ij


### –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä–∞ –∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã

–°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º x –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –µ–º—É —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ–º ùúÜ 
–º–∞—Ç—Ä–∏—Ü—ã A –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –≤–µ–ª–∏—á–∏–Ω—ã, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö —Å–ª–µ–¥—É—é—â–µ–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –∏–º–µ–µ—Ç 
–Ω–µ–Ω—É–ª–µ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ:
A v = ùúÜ v

–í –æ–±—â–µ–º —Å–ª—É—á–∞–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ 
—Ç—Ä–µ–±—É–µ—Ç —Ä–µ—à–µ–Ω–∏—è –º–∞—Ç—Ä–∏—á–Ω–æ–≥–æ —É—Ä–∞–≤–Ω–µ–Ω–∏—è:
(A ‚àí ùúÜ I) v = 0 ,

–ú–∞—Ç—Ä–∏—Ü–∞ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–ª–æ–∂–µ–Ω–∞ –Ω–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ 
A = U R U‚É∞
R - –¢—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã, —Å–æ–¥–µ—Ä–∂–∞—â–µ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –≥–ª–∞–≤–Ω–æ–π –¥–∏–∞–≥–æ–Ω–∞–ª–∏
U - —É–Ω–∏—Ç–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ U* = U^-1
U*- —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ 
–ï—Å–ª–∏ A - –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —Ç–æ AA* = A*A, —Ç–æ –º–∞—Ç—Ä–∏—Ü–∞ R- –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
–ï—Å–ª–∏ A –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —ç—Ä–º–∏–∏—Ç–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞ —Ç–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è - –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞. 


### –°–ª–µ–¥ –º–∞—Ç—Ä–∏—Ü—ã

–°–ª–µ–¥ –º–∞—Ç—Ä–∏—Ü—ã tr(A) - —ç—Ç–æ —Å–∫–∞–ª—è—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ
—Ä–∞–≤–Ω–æ —Å—É–º–º–µ –≤—Å–µ—Ö –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —ç—Ç–æ–π –º–∞—Ç—Ä–∏—Ü—ã
–°–ª–µ–¥ –º–∞—Ç—Ä–∏—Ü—ã —Ä–∞–≤–µ–Ω —Å—É–º–º–µ –µ–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
 */

#include <stdio.h>
#include <math.h>
#define N 3 // –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–∞—Ü–∏—è
// –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –º–∞—Ç—Ä–∏—Ü–∞–º–∏
void  print_m (const float *A);
void  print_mn(float* A, unsigned m, unsigned n);
void  mov_m	 (const float* a, float *r);
void  mov_mn (const float* a, float *r, unsigned m, unsigned n);
void  mul_m  (const float* A, const float* B, float* R);
void  mul_mn  (const float* A, const float* B, float* R, unsigned m, unsigned n);
void  gemv   (const float* A, const float* x, const float* b,  float* r);
void  axpy	 (const float* A, const float* x, float* y);
int   cmp_m  (const float* a, const float* b);
int   cmp_eps_m (const float* a, const float* b, float eps);
int cmp_eps_mn(const float* a, const float* b, float eps, unsigned m, unsigned n);
float det_m  (const float *lu);
float trace_m(const float *a);
// –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å A=LU, A=LDU, A=LDL^T
void lu_comp	(const float *lu, float* r);
void ldu_comp	(const float *lu, float* r);
void ldl_comp	(const float *lu, float* r);
// –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ A=LU
void lu_decomp  (float *L, float *U, const float *A);
void lu_decomp1 (float *M);
void lu_decomp2 (float *LU, const float *A);
void lu_decomp3 (float *LU, const float *A);
void ldu_decomp (float *LDU,const float *A);
// —Ä–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —É—Ä–∞–≤–Ω–µ–Ω–∏–π Ax=C
void lu_solve   (const float *LU, float *x, const float *c);
void lup_solve	(const float *lu, const int *p, float *z, const float *c);
void ldu_solve  (const float *LDU,float *x, const float *c);
void lu_inv 	(const float *LU, float *A_inv);
void lup_inv 	(const float *LU, const int *P, float *A_inv);
void ldu_inv 	(const float *LDU,float *A_inv);
void lu_inv_l 	(const float *LU, float *L_inv);
void lu_inv_u 	(const float *LU, float *U_inv);
float lu_det 	(const float *LU);
// —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö –∏ —ç—Ä–º–∏—Ç–æ–≤—ã—Ö –º–∞—Ç—Ä–∏—Ü
void cholesky_decomp(float * L, const float *A);
void cholesky_ldl_decomp(float * L, const float *A);
void cholesky_ldl_solve(const float * L, float *z, const float* c);
void cholesky_ldl_inv  (const float * L, float *z);
float cholesky_ldl_det (const float * L);
// —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ –¥–ª—è –∞–Ω—Ç–∏-—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü
// —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ QR
int  qr_cgs_decomp(float* a, float* r, unsigned m, unsigned n);
int  qr_decomp	  (float* a, float* r, unsigned m, unsigned n);
int  qr_givens  (float* a, float* r, unsigned m, unsigned n);
int  qr_house   (float* a, float* r, unsigned m, unsigned n);
int qr_house2(float * a, float* tau, unsigned m, unsigned n);
int qr_house_unpack(float * a, float * tau,  float * q, float * r, unsigned m,  unsigned n);
// —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –®—É—Ä–∞
// —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ SVD
// –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü
int  is_hermitian (const float* A, int n);
int  is_symmetric (const float* A, int n);
int  is_skew_symmetric(const float* A, int n);
int  is_orthogonal(const float* A, int n);
int  is_orthonormal(const float* A, unsigned m, unsigned n);
int  is_normal(const float* A, unsigned n);// –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ A'A == AA'
int  is_hessenberg(const float* A, int n);// –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–∞—Ç—Ä–∏—Ü—É –•–µ—Å—Å–µ–Ω–±–µ—Ä–≥–∞, –≤—Å–µ –Ω—É–ª–∏ –ø–æ–¥-–¥–∏–∞–≥–æ–Ω–∞–ª—å—é
int  is_tridiagonal(const float* A, int n);
int  is_singular  (const float* A, int n);// –º–æ–∂–µ—Ç –º–∞—Ç—Ä–∏—Ü–∞ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–∞—è? –°—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü—ã –º–∞—Ç—Ä–∏—Ü—ã –ª–∏–Ω–µ–π–Ω–æ –∑–∞–≤–∏—Å–∏–º—ã.

/* A is Hermitian  \iff A={\overline{A}^{\mathsf{T}}}.

$${\displaystyle A{\text{ is Hermitian}}\quad \iff \quad A={\overline {A^{\mathsf{T}}}}.}$$
 */

int main()
{
	float eps = N*__FLT_EPSILON__;
	float A [3*3]= {
	25, 5, 4,
	10, 8,16,
	8 ,12,22,
	};
	float B [3*3]= {
	25, 5, 4,
	 0, 8,16,
	 0,12,22,
	};
	float A1[3*3]= {
	10,-7, 0,
	-3, 6, 2,
	 5,-1, 5,
	};
	float LU1[3*3]= {
	10,-7, 0,
	-0.3, -0.1, 6,
	 0.5, -25, 155,
	};

	float C[3*3]= {
	4,12, -16,
	12,37, -43,
	-16,-43,98,
	};
	float LC[3*3]= {
	2,0,0,
	6,1,0,
	-8,5,3,
	};
	float D[3*3]= {
	1.4, 1, 1,
	1, 0.9, 1,
	1, 1, 1.4,
	};
	float LD[3*3]= {
	1.4, 0, 0,
	0.7143, 0.1857, 0,
	0.7143, 1.5385, 0.2462,
	};
	float L1[3*3]= {
	2, 0, 0,
	8,-7, 0,
	4, 9,-27,
	};
	float E1[3*3]= {
	1, 0, 0,
	0, 1, 0,
	0, 0, 1,
	};
		
	
	float L [3*3];
	float U [3*3];
	float M [3*3];
	float M1[3*3];
	lu_decomp(L, U, A);
	print_m (L);
	print_m (U);
	
	mul_m(L,U, M);
	if(cmp_m(M,A)) printf("..ok\n");
	else printf("..fail\n");
	
//	printf("LU decomp1\n");
	lu_decomp1(M);
	print_m (M);
//	if(cmp_m(M,M1)) printf("..ok\n");
//	else printf("..fail\n");

	printf("LU decomp2\n");
	lu_decomp2(M1,A);
	print_m (M1);
	if(cmp_eps_m(M,M1, 2*eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("LU compose\n");
	lu_comp(M1,B);
	print_m (B);
	if(cmp_eps_m(B,A, 2*eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("LU decomp3\n");
	lu_decomp3(M1,A);
	print_m (M1);
	if(cmp_eps_m(M,M1,2*eps)) printf("..ok\n");
	else printf("..fail\n");

printf("\n");
	lu_decomp(L, U, B);
	print_m (L);
	print_m (U);
	mul_m(L,U, M);
	if(cmp_m(M,B)) printf("..ok\n");
	else printf("..fail\n");

	printf("LU decomp1\n");
	mov_m(B,M);
	lu_decomp1(M);
	print_m (M);
	if(cmp_eps_m(M,M1, 2*eps)) printf("..ok\n");
	else printf("..fail\n");

	lu_decomp2(M,B);
	print_m (M);
	printf("inversion\n");
	float B_inv[3*3];
	float E[3*3];
	lu_inv(M,B_inv);
	mul_m(B,B_inv, E);
	print_m (E);
	if(cmp_eps_m(E,E1, N*eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("inversion L matrix\n");
	lu_decomp(L, U, B_inv);
	print_m (L);
	printf("inversion L_inv\n");
	lu_decomp2(M,B);
	lu_inv_l(M, B_inv);
	print_m (B_inv);
	lu_decomp(L, U, B);
	mul_m(L,B_inv, E);
	//print_m (E);
	if(cmp_eps_m(E,E1, eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("inversion U matrix\n");
	lu_inv_u(M, B_inv);
	mul_m(U,B_inv, E);// –µ—Å–ª–∏ –µ—Å—Ç—å –¥–µ–ª–µ–Ω–∏–µ, —Ç–µ—Ä—è–µ—Ç—Å—è —Ç–æ—á–Ω–æ—Å—Ç—å
	if(cmp_eps_m(E,E1, eps)) printf("..ok\n");
	else printf("..fail\n");

// \todo –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é —Å–µ—Ä–∏—é ldu_inv
	printf("LDU inversion\n");
	ldu_decomp(M,B);
	ldu_inv(M,B_inv);
	mul_m(B,B_inv, E);
	if(cmp_eps_m(E,E1, N*eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("Cholesky LL decomp\n");
	cholesky_decomp(L, C);
	print_m (L);
	if(cmp_m(L,LC)) printf("..ok\n");
	else printf("..fail\n");

	printf("Cholesky LDL decomp\n");
	cholesky_ldl_decomp(L, D);
	print_m (L);
	if(cmp_eps_m(L,LD, N*eps)) printf("..ok\n");
	else printf("..fail\n");

	printf("Cholesky LDL solve\n");
	float Ev[3] = {1,1,1};
	float  v[3];
	cholesky_ldl_solve(L, v, Ev);
	printf("v = %1.8f %1.8f %1.8f\n",v[0],v[1],v[2]);

	printf("LU solve\n");
	lu_decomp2(L, D);
	lu_solve(L, v, Ev);
	printf("v = %1.8f %1.8f %1.8f\n",v[0],v[1],v[2]);
	printf("LDU solve\n");
	ldu_decomp(L, D);
	ldu_solve(L, v, Ev);
	printf("v = %1.8f %1.8f %1.8f\n",v[0],v[1],v[2]);

	printf("Test decomp-mul\n");

	lu_decomp(L,U,A1);
	print_m (L);
	print_m (U);
	mul_m(L,U, M);
	if(cmp_m(M,A1)) printf("..ok\n");

	float Q[3*3] = {
		1, 1, 2,
		1, 0,-2,
	   -1, 2, 3
	};
	float R[3*3]={0};// –ø—É—Å—Ç–æ
	printf("QR decomp (QR Modified Gram-Schmidt)\n");
	mov_m(Q,A1);
	qr_decomp(Q, R, N, N);
	print_m (Q);
	print_m (R);
	mul_m(Q,R,M);
	print_m (M);
	if(cmp_eps_m(M,A1, eps)) printf("..ok\n");
	if (is_orthogonal(Q, N)) printf("..is_orthogonal\n");
	if (is_orthonormal(Q, N, N)) printf("..is_orthonormal\n");
	if (is_normal(Q, N)) printf("..is_normal\n");
	
	printf("QR decomp (QR Classical Gram-Schmidt)\n");
	float Q1[3*3] = {
		1, 1, 2,
		1, 0,-2,
	   -1, 2, 3
	};
	qr_cgs_decomp(Q1, R, N, N);
	print_m (Q1);
	print_m (R);
	if (is_orthogonal(Q1, N)) printf("..is_orthogonal\n");
	if (is_orthonormal(Q1, N, N)) printf("..is_orthonormal\n");
	if (is_normal(Q1, N)) printf("..is_normal\n");
	
	float G[3*3] = {
		1, 1, 2,
		1, 0,-2,
	   -1, 2, 3
	};
	printf("QR decomp (QR Givens)\n");
	qr_givens(G,R, N, N);

	float H[3*3] = {
		1, 1, 2,
		1, 0,-2,
	   -1, 2, 3
	};
	printf("QR decomp (QR Householder)\n");
	float tau[N];
	mov_m(H,A1);
	qr_house (H,tau, N, N);

	print_m (H);
	qr_house_unpack(H, tau, Q, R, N, N);
	print_m (Q);
	print_m (R);
	mul_m(Q,R,M);
	print_m (M);
	if(cmp_eps_m(M,A1, eps)) printf("..ok\n");
	if (is_orthogonal(Q, N)) printf("..is_orthogonal\n");
	if (is_orthonormal(Q, N, N)) printf("..is_orthonormal\n");
	if (is_normal(Q, N)) printf("..is_normal\n");

	float H1[3*3] = {
		1, 1, 2,
		1, 0,-2,
	   -1, 2, 3
	};

	printf("QR decomp (QR Householder)\n");

	qr_house (H1,tau, N, N);
	print_m (H1);
	qr_house_unpack(H1, tau, Q, R, N, N);
	mul_m(Q,R,M);
	if(cmp_eps_m(M,A1, eps)) printf("..ok\n");
	if (is_orthogonal(Q, N)) printf("..is_orthogonal\n");
	if (is_orthonormal(Q, N, N)) printf("..is_orthonormal\n");
	if (is_normal(Q, N)) printf("..is_normal\n");

	float A4[] = { 
/*		2,1,0,0,
		1,2,1,0,
		0,1,2,1,
		0,0,1,2}; */
		0.18, 0.60, 0.57, 0.96,
		0.41, 0.24, 0.99, 0.58,
		0.14, 0.30, 0.97, 0.66,
		0.51, 0.13, 0.19, 0.85 }; 
	float tau4[4];
	float B4[4*4];
	float Q4[4*4];
	float R4[4*4];
	float M4[4*4];
	mov_mn(A4, B4, 4, 4);
	mov_mn(A4, Q4, 4, 4);
	qr_decomp(Q4,R4, 4, 4);
//	qr_cgs_decomp(Q4,R4, 4, 4);
	mul_mn(Q4,R4,M4,4,4);
	print_mn(M4, 4, 4);
	if(cmp_eps_mn(M4,B4, eps, 4,4)) printf("..ok\n");
	qr_house(A4,tau4, 4, 4);
	qr_house_unpack(A4, tau4, Q4, R4, 4, 4);
	print_mn(Q4, 4, 4);
	print_mn(R4, 4, 4);
	mul_mn(Q4,R4,M4,4,4);
	if(cmp_eps_mn(M4,B4, eps, 4,4)) printf("..ok\n");
	if (is_orthogonal(Q4, 4)) printf("..is_orthogonal\n");
/*!
octave> A = [ 0.18, 0.60, 0.57, 0.96;
              0.41, 0.24, 0.99, 0.58;
              0.14, 0.30, 0.97, 0.66;
              0.51, 0.13, 0.19, 0.85 ];

octave> x = [ -4.05205; -12.6056; 1.66091; 8.69377];

octave> A * x
ans =
  1.0000
  2.0000
  3.0000
  4.0000 */
	return 0;
}
/*! \brief –≤—ã–≤–æ–¥ –Ω–∞ —ç–∫—Ä–∞–Ω –ø–µ—á–∞—Ç—å –º–∞—Ç—Ä–∏—Ü NxN
 */
void  print_m(const float *A)
{
	for(int i=0; i<N; i++){
		for(int j=0; j<N; j++){
			printf("\t%1.3f,", A[i*N + j]);
		}
		printf("\n");
	}
	printf("\n");
}
/*! \brief –ø–µ—á–∞—Ç–∞–µ—Ç –º–∞—Ç—Ä–∏—Ü—É m x n
	\param A - –º–∞—Ç—Ä–∏—Ü–∞
	\param m - —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫ 
	\param n - —á–∏—Å–ª–æ —Å—Ç–æ–ª–±—Ü–æ–≤
 */
void print_mn(float* A, unsigned m, unsigned n){
	for(int i=0; i<m; i++){
		for(int j=0; j<n; j++){
			printf("\t%f,", A[i*n + j]);
		}
		printf("\n");
	}
	printf("\n");	
}
/* –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É */
void  mov_m	 (const float* a, float *r)
{
	for(int i=0;i<N*N; i++){
		r[i] = a[i];
	}
}
void  mov_mn (const float* a, float *r, unsigned m, unsigned n)
{
	unsigned i, j;
	for(i=0;i<m; i++)
	for(j=0;j<n; j++){
		r[i*n+j] = a[i*n+j];
	}
}
/*! \brief —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü  
	\param r —Ä–µ–∑—É–ª—å—Ç–∞—Ç R = AB
 */
void mul_m(const float* a, const float* b, float* r)
{
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		float s = 0;
		for (int k=0; k<N; k++)
			s += a[i*N+k]*b[k*N+j];
		r[i*N+j] = s; 
	}	
}
void mul_mn(const float* a, const float* b, float* r, unsigned m, unsigned n)
{
	unsigned i,j,k;
	for (i=0; i<m; i++)
	for (j=0; j<n; j++){
		float s = 0;
		for ( k=0; k<n; k++)// —Ç—É—Ç –¥—Ä—É–≥–∞—è —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å
			s += a[i*n+k]*b[k*n+j];
		r[i*n+j] = s; 
	}	
}
/*! \brief —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ –≤–µ–∫—Ç–æ—Ä 
	\param r - —Ä–µ–∑—É–ª—å—Ç–∞—Ç r = Ax+b
 */
void gemv(const float* a, const float* x, const float* b,  float* r)
{
	for (int i=0; i<N; i++) {
		float s = 0;
		for (int k=0; k<N; k++)
			s += a[i*N+k]*x[k];
		r[i] = s + b[i]; 
	}	
}
/*! \brief —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ –≤–µ–∫—Ç–æ—Ä 
	\param y - —Ä–µ–∑—É–ª—å—Ç–∞—Ç y = Ax+y
 */
void axpy(const float* a, const float* x, float* y)
{
	for (int i=0; i<N; i++) {
		float s = y[i];
		for (int k=0; k<N; k++)
			s += a[i*N+k]*x[k];
		y[i] = s; 
	}	
}
/*! \brief –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞ - –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –º–∞—Ç—Ä–∏—Ü—ã 
	–î–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è. 
	
	det(A)=det(LU)=det(L)det(U)
	–û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã (–Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –µ–¥–∏–Ω–∏—Ü—ã) —Ä–∞–≤–µ–Ω –µ–¥–∏–Ω–∏—Ü–µ
	–û–¥–Ω–∞ –∏–∑ –º–∞—Ç—Ä–∏—Ü LU - —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è
*/
float det_m(const float *lu){
	float d = 1.f;
	for (int i=0; i<N; i++){
		d *= lu[i*N+i];
	}
	return d;
}
/*! \brief –°–ª–µ–¥ –º–∞—Ç—Ä–∏—Ü—ã (trace) - c—É–º–º–∞ –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
float trace_m(const float *a){
	float d = 0.0f;
	for (int i=0; i<N; i++){
		d += a[i*N+i];
	}
	return d;
}
/*! \brief —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–≤—É—Ö –º–∞—Ç—Ä–∏—Ü */
int cmp_m(const float* a, const float* b)
{
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		if (a[i*N+j]!=b[i*N+j]) return 0;
	}
	return 1;
}
int cmp_eps_m(const float* a, const float* b, float eps)
{
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		if (fabs(a[i*N+j]-b[i*N+j]) >= eps) return 0;
	}
	return 1;
}
int cmp_eps_mn(const float* a, const float* b, float eps, unsigned m, unsigned n)
{
	unsigned i,j;
	for (i=0; i<m; i++)
	for (j=0; j<n; j++){
		if (fabs(a[i*n+j]-b[i*n+j]) >= eps) return 0;
	}
	return 1;
}

/*! \brief —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü R = LU –ø–æ–ª—É—á–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É
	\param lu —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã L –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è (–µ–¥–∏–Ω–∏—Ü—ã –Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏), U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è
	\param r - —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É–º–Ω–æ–∂–µ–Ω–∏—è LU, –º–∞—Ç—Ä–∏—Ü–∞ NxN
 */
void lu_comp(const float *lu, float* r)
{
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		int m = i<=j? i:j;
		float s = 0;
		for (int k=0; k<m; k++) 	//if (k<i && k<j)
			s = fmaf(lu[i*N+k],lu[k*N+j],s);
		if (j< i) s += (lu[i*N+j]*lu[j*N+j]);// —Å—Ç—Ä–æ–∫–∞ –º–µ–Ω—å—à–µ
		else s += lu[i*N+j]; 	// –¥–æ–±–∞–≤–∏—Ç—å –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —É–º–Ω–æ–∂–∞–µ—Ç—Å—è –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É
		r[i*N+j] = s; 
	}	
}
/*! \brief –†–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —Å–∏—Å—Ç–µ–º—ã –ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π –°–õ–ê–£ —á–µ—Ä–µ–∑ LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ 
  \param lu - –¥–≤–µ –º–∞—Ç—Ä–∏—Ü—ã —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã - —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–º, –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –≤–µ—Ä—Ö–Ω–µ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ U, –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è L - –Ω–∏–∂–Ω–µ–π —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–¥–∏–Ω–∏—á–Ω—ã–µ —ç–ª–º–µ–Ω—Ç—ã –Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏.

  –†–µ—à–µ–Ω–∏–µ A x = b
  LU x = b
  1.  L y = b -- –Ω–∞—Ö–æ–¥–∏–º –≤–µ–∫—Ç–æ—Ä y
  2.  U x = y -- –Ω–∞—Ö–æ–¥–∏–º –≤–µ–∫—Ç–æ—Ä x

 */
void lu_solve (const float *lu, float *z, const float *c){
	z[0] = c[0];
	for (int i=1; i<N; i++){//  L y = c
		float s = 0;
		for (int k=0; k<i; k++)
			s = fmaf(lu[i*N+k],z[k],s);
		z[i] = c[i]-s;
	}
	z[N-1] /= lu[N*N-1];
	for (int i=N-2; i>=0; i--){// U z = y
		double s = 0;
		for (int k=i+1; k<N; k++)
			s = fmaf(lu[i*N+k],z[k],s);
		z[i] = (z[i] - s)/lu[i*N+i];
	}
}
/*! 
\see https://en.wikipedia.org/wiki/LU_decomposition
 */
void lup_solve (const float *lu, const int *p, float *z, const float *c){
	z[0] = c[p[0]];
	for (int i=1; i<N; i++){//  L y = c
		z[i] = c[p[i]];
		float s = 0;
		for (int k=0; k<i; k++)
			s += lu[i*N+k]*z[k];
		z[i] = z[i]-s;
	}
	z[N-1] /= lu[N*N-1];
	for (int i=N-2; i>=0; i--){// U z = y
		float s = 0;
		for (int k=i+1; k<N; k++)
			s += lu[i*N+k]*z[k];
		z[i] = (z[i]-s)/lu[i*N+i];
	}
}
/*! \brief –†–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —Å–∏—Å—Ç–µ–º—ã –ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π –°–õ–ê–£ —á–µ—Ä–µ–∑ LDU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ 
	\param ldu - –¥–≤–µ –º–∞—Ç—Ä–∏—Ü—ã —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã, 
  L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, 
  D - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞
  U - –≤–µ—Ä—Ö–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, 
  
  –†–µ—à–µ–Ω–∏–µ A x = b
  LDU x = b
  1.  L y = b -- –Ω–∞—Ö–æ–¥–∏–º –≤–µ–∫—Ç–æ—Ä y
  2.  D z = y -- –Ω–∞—Ö–æ–¥–∏–º –≤–µ–∫—Ç–æ—Ä z
  2.  U x = z -- –Ω–∞—Ö–æ–¥–∏–º –≤–µ–∫—Ç–æ—Ä x

 */
void ldu_solve (const float *ldu, float *z, const float *c){
	z[0] = c[0];
	for (int i=1; i<N; i++){//  L y = c
		z[i] = c[i];
		float s = 0;
		for (int k=0; k<i; k++)
			s = fmaf(ldu[i*N+k],z[k],s);
		z[i] = z[i]-s;
	}
	for (int i=0; i<N; i++)		// D z = y
		z[i] /= ldu[N*i+i];
	for (int i=N-2; i>=0; i--){	// U x = z
		float s = 0;
		for (int k=i+1; k<N; k++)
			s = fmaf(ldu[i*N+k],z[k],s);
		z[i] = z[i] - s;
	}
}
/*! \brief –ú–µ—Ç–æ–¥ –∏–Ω–≤–µ—Ä—Å–∏–∏ –º–∞—Ç—Ä–∏—Ü—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º LDU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è
	\note —Å—Ç–æ–ª–±—Ü—ã –º–∞—Ç—Ä–∏—Ü—ã –º–æ–∂–Ω–æ –≤—ã—á–∏—Å–ª—è—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
 */
void ldu_inv (const float *ldu, float *z){
	for (int i=0; i<N; i++){
		for (int j=0; j<N; j++)	z[i*N+j] = 0;
		z[i*N+i] = 1;
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		for (int i=1; i<N; i++){//  L y = c
			float s = 0;
			for (int k=0; k<i; k++)
				s += ldu[i*N+k]*z[k*N+j];
			z[i*N+j] = z[i*N+j]-s;
		}
		for (int i=0; i<N; i++)		// D z = y
			z[i*N+j] /= ldu[N*i+i];
		for (int i=N-2; i>=0; i--){	// U x = z
			float s = 0;
			for (int k=i+1; k<N; k++)
				s += ldu[i*N+k]*z[k*N+j];
			z[i*N+j] = z[i*N+j] - s;
		}
	}
}
/*! \brief –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã 
	—Ç–µ–º –∂–µ –º–µ—Ç–æ–¥–æ–º, —á—Ç–æ –∏ —Ä–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã E: AX = E
	
	–û–±—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –µ—Å–ª–∏ –¥–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç det(A) !=0 
	–ò–Ω–∞—á–µ –±—É–¥–µ—Ç –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å!
	
  \param [in] lu - –¥–≤–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã - —Ä–µ–∑—É–ª—å—Ç–∞—Ç LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–º, –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –≤–µ—Ä—Ö–Ω–µ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ U, –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è L - –Ω–∏–∂–Ω–µ–π —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–¥–∏–Ω–∏—á–Ω—ã–µ —ç–ª–º–µ–Ω—Ç—ã –Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏.
  \param [out] z - –æ–±—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞. 
  
 */
void lu_inv (const float *lu, float *z){
	for (int i=0; i<N; i++){
		for (int j=0; j<N; j++)	z[i*N+j] = 0;
		z[i*N+i] = 1;
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		for (int i=1; i<N; i++){//  L y = c
			float s = 0;
			for (int k=0; k<i; k++)
				s += lu[i*N+k]*z[k*N+j];
			z[i*N+j] = z[i*N+j]-s;
		}
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		z[(N-1)*N+j] /= lu[N*N-1];
		for (int i=N-2; i>=0; i--){// U z = y
			float s = 0;
			for (int k=i+1; k<N; k++)
				s += lu[i*N+k]*z[k*N+j];
			z[i*N+j] = (z[i*N+j]-s)/lu[i*N+i];
		}
	}
}
/*! \brief –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è
	\param p –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫
	\param z –æ–±—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞
 */
void lup_inv   (const float *lu, const int *p, float *z){
	for (int i=0; i<N; i++){
		for (int j=0; j<N; j++)	
			z[i*N+j] = p[j]==i?1.0:0.0;
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		for (int i=1; i<N; i++){//  L y = c
			float s = 0;
			for (int k=0; k<i; k++)
				s += lu[i*N+k]*z[k*N+j];
			z[i*N+j] = z[i*N+j]-s;
		}
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		z[(N-1)*N+j] /= lu[N*N-1];
		for (int i=N-2; i>=0; i--){// U z = y
			float s = 0;
			for (int k=i+1; k<N; k++)
				s += lu[i*N+k]*z[k*N+j];
			z[i*N+j] = (z[i*N+j]-s)/lu[i*N+i];
		}
	}
}
float lu_det (const float *lu){
	float d = lu[0];
	for (int i=1;i<N;i++){
		d*=lu[i*N+i];
	}
	return d;
}
/*! 
\todo —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞ –¥–≤—É—Ö –æ–±—Ä–∞—Ç–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü U^{-1}L^{-1} –¥–ª—è  LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è 
–æ–±—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ –¥–ª—è L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è. –î–ª—è U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è.
\todo –Ω–∞–¥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å, –Ω–µ –æ—Ç–ª–∞–∂–µ–Ω–æ
 */
void lu_inv_l (const float *lu, float *z){

	for (int i=0; i<N; i++){
		for (int j=0; j<N; j++)	z[i*N+j] = 0;
		z[i*N+i] = 1;
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		for (int i=1; i<N; i++){//  L y = c
			float s = 0;
			for (int k=0; k<i; k++)
				s += lu[i*N+k]*z[k*N+j];
			z[i*N+j] = z[i*N+j]-s;
		}
	}
}

void lu_inv_u (const float *lu, float *z){

	for (int i=0; i<N; i++){
		for (int j=0; j<N; j++)	z[i*N+j] = 0;
		z[i*N+i] = 1;
	}
	for (int j=0; j<N; j++) {// —Å—Ç–æ–ª–±–µ—Ü
		z[(N-1)*N+j] /= lu[N*N-1];
		for (int i=N-2; i>=0; i--){// U z = y
			float s = 0;
			for (int k=i+1; k<N; k++)
				s = fmaf(lu[i*N+k],z[k*N+j],s);
			z[i*N+j] = (z[i*N+j]-s)/lu[i*N+i];
		}
	}
}


/*! \brief –ú–µ—Ç–æ–¥ LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
 */
void lu_decomp1 (float *a)
{
	for(int i=0; i<N; i++) { // decompose M in M=L*U
		for(int j=i+1; j<N; j++) {
			float s = a[N*j+i] / a[N*i+i];
			a[N*j+i] = s;
			for(int k=i+1; k<N; k++) 
				a[N*j+k] -= s*a[N*i+k];
		}
	}
}
/*! \brief –ú–µ—Ç–æ–¥ LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã A = LU (–ê–ª–≥–æ—Ä–∏—Ç–º –î—É–ª–∏—Ç—Ç–ª–∞)
	\param LU - –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –∏–∑ –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü
	L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, 
	U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã LU –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ U
	\param A -- –∏—Å—Ö–æ–¥–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞
	
	–ê–ª–≥–æ—Ä–∏—Ç–º –ö—Ä–æ—É—Ç–∞ - —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ —Å—á–∏—Ç–∞–µ—Ç LU –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º
	U - —É–Ω–∏—Ç—Ä–µ–Ω—É–≥–æ–ª—å–Ω–æ–π, L - —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π. 
	–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –Ω–∞–¥–æ –ø–æ–º–µ–Ω—è—Ç—å i j –≤ —Ä–∞—Å—á–µ—Ç–µ –∏ —Å—á–∏—Ç–∞—Ç—å –≤ —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –≤–∏–¥–µ.
 */
void lu_decomp2 (float *LU, const float *A)
{
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		float s=0;
		if (i<=j) {
			for(int k=0; k<i;k++)
				s += (LU[i*N+k]*LU[k*N+j]);
			LU[i*N+j] =  A[i*N+j] - s;
		} else {
			for(int k=0; k<j;k++)
				s += (LU[i*N+k]*LU[k*N+j]);
			LU[i*N+j] = (A[i*N+j] - s)/LU[j*N+j];
		}
	}
}
// lu = L+U-I
void lu_decomp3(float *L, const float *A)
{
	for (int i=0; i<N; i++) {// L -- –Ω–∏–∂–Ω—è—è —á–∞—Å—Ç—å
		for (int j=0; j<i; j++){
			float s=0;
			for(int k=0; k<j;k++)
				s = fmaf(L[i*N+k],L[k*N+j],s);
			L[i*N+j] = (A[i*N+j] - s)/L[j*N+j];
		}
		for (int j=i; j<N; j++){// U1 -- –≤–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã
			float s=0;
			for(int k=0; k<i;k++)
				s+= L[i*N+k]*L[k*N+j];
			L[i*N+j] = (A[i*N+j] - s);
		}
	}
}
/*! \brief –ú–µ—Ç–æ–¥ LDU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã A = LDU 
	\param LU - –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –∏–∑ –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü –∏ –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π
	L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, 
	U - –≤–µ—Ä—Ö–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, 
	D - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã LU

 */
void ldu_decomp (float *L, const float *A)
{
	for (int i=0; i<N; i++) {// L -- –Ω–∏–∂–Ω—è—è —á–∞—Å—Ç—å
		for (int j=0; j<i; j++){
			float s=0;
			for(int k=0; k<j;k++)
				s= fmaf(L[i*N+k],L[k*N+j],s);
			L[i*N+j] = (A[i*N+j] - s)/L[j*N+j];
		}
		for (int j=i; j<N; j++){// U1 -- –≤–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã
			float s=0;
			for(int k=0; k<i;k++)
				s= fmaf(L[i*N+k],L[k*N+j],s);
			L[i*N+j] = (A[i*N+j] - s);
		}
/*		
			if (i<=j) {	// U1 -- –≤–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã
				for(int k=0; k<i;k++)
					s+= L[i*N+k]*L[k*N+j];
				L[i*N+j] = (A[i*N+j] - s);
			} else {	// L -- –Ω–∏–∂–Ω—è—è —á–∞—Å—Ç—å
				for(int k=0; k<j;k++)
					s+= L[i*N+k]*L[k*N+j];
				L[i*N+j] = (A[i*N+j] - s)/L[j*N+j];
			}
		}*/
	}
	for (int i=0; i<N-1; i++){// –í—ã–¥–µ–ª–∏—Ç—å U1 = DU, –≥–¥–µ U - —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –≤–µ—Ä—Ö–Ω—è—è
		float d = 1/ L[i*N+i];
		// vector_t v = subrow(L, i, i+1, N-(i+1));
		// BLAS(scal)(v, d);
		for (int j=i+1; j<N; j++)
			L[i*N+j] *= d;
	}
}
/*! \brief –ú–µ—Ç–æ–¥ LU —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã A = LU 
 */
void lu_decomp (float *LL, float *UU, const float *A)
{
	float L[N][N] = {0};
	float U[N][N] = {0};
	for (int i=0; i<N; i++)	L[i][i] = 1;
	
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		float s=0;
		if (i<=j) {
			for(int k=0; k<i;k++)
				s+= L[i][k]*U[k][j];
			U[i][j] =  A[i*N+j] - s;
		} else {
			for(int k=0; k<j;k++)
				s+= L[i][k]*U[k][j];
			L[i][j] = (A[i*N+j] - s)/U[j][j];
		}
	}
	for (int i=0; i<N; i++) 
	for (int j=0; j<N; j++)
		LL[i*N+j] = L[i][j];
	for (int i=0; i<N; i++) 
	for (int j=0; j<N; j++)
		UU[i*N+j] = U[i][j];
}
void lu_decomp_ (float *LU, const float *A)
{
	float L[N][N];
	float U[N][N];
	
	for (int i=0; i<N; i++)
	for (int j=0; j<N; j++){
		float s=0;
		if (i<=j) {
			for(int k=0; k<i;k++)
				s+= L[i][k]*U[k][j];
			U[i][j] =  A[i*N+j] - s;
		} else {
			for(int k=0; k<j;k++)
				s+= L[i][k]*U[k][j];
			L[i][j] = (A[i*N+j] - s)/U[j][j];
		}
	}
	for (int i=0; i<N; i++) 
	for (int j=0; j<N; j++)
		LU[i*N+j] = j<i?L[i][j]:U[i][j];
}
/*! \brief –†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ A = LL^T, –ø–æ—Å–ª–µ–¥—É—é—â–µ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ LDL^T

### LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ (–†–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ)
LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ 
–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π –¥–≤—É—Ö –º–∞—Ç—Ä–∏—Ü:
A = L L*
A = U* U
–≥–¥–µ:
L - –Ω–∏–∂–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞; U - –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.
–î–ª—è –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü: L* = L^‚ä§ –∏ U* = U^‚ä§.

–î–ª—è –Ω–µ—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü—ã —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω–æ –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å, 
–Ω–æ –æ–Ω–æ –Ω–µ –±—É–¥–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –∏—Å—Ö–æ–¥–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ A

–°—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –•–æ–ª–µ—Ü–∫–æ–≥–æ:
‚àô –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –•–æ–ª–µ—Ü–∫–æ–≥–æ;
(–≤ –µ–≥–æ –æ—Å–Ω–æ–≤–µ –º–µ—Ç–æ–¥ –∏—Å–∫–ª—é—á–µ–Ω–∏—è –ì–∞—É—Å—Å–∞ –ø—Ä–∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–∏ –∏—Å—Ö–æ–¥–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –∫ –Ω–∏–∂–Ω–µ—Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–º—É –≤–∏–¥—É)
‚àô –∞–ª–≥–æ—Ä–∏—Ç–º –•–æ–ª–µ—Ü–∫–æ–≥–æ-–ë–∞–Ω–∞—Ö–µ–≤–∏—á–∞;
(–∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã L –Ω–∞—á–∏–Ω–∞—è —Å –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –∏ –¥–∞–ª–µ–µ –∏—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ –ø–æ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ)
‚àô –∞–ª–≥–æ—Ä–∏—Ç–º –•–æ–ª–µ—Ü–∫–æ–≥–æ-–ö—Ä–æ—É—Ç–∞;
(–∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü—ã U –Ω–∞—á–∏–Ω–∞—è —Å –ø–µ—Ä–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ –∏ –¥–∞–ª–µ–µ –∏—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ –ø–æ –∫–∞–∂–¥–æ–º—É —Å—Ç–æ–ª–±—Ü—É)
–ê–ª–≥–æ—Ä–∏—Ç–º –ö—Ä–æ—É—Ç–∞ –≤ –æ–±–æ–±—â–µ–Ω–Ω–æ–º –≤–∏–¥–µ —è–≤–ª—è–µ—Ç—Å—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏—è LU-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è,
–≥–¥–µ L - –Ω–∏–∂–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è, –∞ U - —É–Ω–∏—Ç–∞—Ä–Ω–∞—è –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è.

 */
void cholesky_decomp(float * L, const float *A)
{
    //__builtin_bzero(L, N*N*sizeof(float));
    for (int i = 0; i < N; i++)
	for (int j = 0; j <= i; j++) {
		float s = 0;
		for (int k = 0; k < j; k++)
			s += L[i*N+k] * /*conj*/(L[j*N+k]);// –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ
		if (j == i) {
			L[i*N+j] = sqrt(A[i*N+j] - s);
		} else {
			L[i*N+j] = (A[i*N+j] - s)/L[j*N+j];
			L[j*N+i] = 0;// /*conj*/(L[i*N+j]);// –º–æ–∂–Ω–æ –Ω–µ –∑–∞–ø–æ–ª–Ω—è—Ç—å –≤–æ–≤—Å–µ
		}
	}
}
/*! \brief LDL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ A = LDL^T
	\param LD - –Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ —Ä–∞—Å–ø–æ–æ–ª–∂–µ–Ω—ã —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Ç—Ä–∏—Ü—ã D
LDL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ (–º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è) –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A - —ç—Ç–æ –µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —Ç—Ä–µ—Ö –º–∞—Ç—Ä–∏—Ü:
A = L D L*
–≥–¥–µ:
D - –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞;
L - –Ω–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.

–ü—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ LDL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è, –≤ –æ—Ç–ª–∏—á–∏–∏ –æ—Ç LL-—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è, –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –∫–æ—Ä–Ω–µ–π, –∞ —É—Å–ª–æ–≤–∏–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è
–æ—Ç–ª–∏—á–∏–µ –æ—Ç –Ω—É–ª—è –≤—Å–µ—Ö —É–≥–ª–æ–≤—ã—Ö –º–∏–Ω–æ—Ä–æ–≤ –∏—Å—Ö–æ–¥–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã A.

$LDL = L D_1 D_1^T L^T$

Theorem #1(Eigendecomposition). A square matrix A ‚àà R^{n√ón} can be factored into
A = P D P^{‚àí1}, 
where P ‚àà R^{n√ón} and D is a diagonal matrix whose diagonal entries are
the eigenvalues of A, if and only if the eigenvectors of A form a basis of R^n.

Theorem #2. A symmetric matrix S ‚àà R^{n√ón} can always be diagonalized

Theorem #3. Given a matrix A ‚àà R^{m√ón}, we can always obtain a symmetric, positive semidefinite matrix S ‚àà R^{n√ón} by defining S := A^‚ä§ A .
*Remark*. If rk(A) = n, then S := A^‚ä§ A is symmetric, positive definite

Theorem #4(Spectral Theorem). If A ‚àà R^{n√ón} is symmetric, there exists an orthonormal basis of the corresponding vector space V consisting of
eigenvectors of A, and each eigenvalue is real.

 */
void cholesky_ldl_decomp(float * L, const float *A)
{
    //__builtin_bzero(L, N*N*sizeof(float));
    for (int i = 0; i < N; i++)
	for (int j = 0; j <= i; j++) {
		float s = 0;
		for (int k = 0; k < j; k++)
			s += L[k*N+k] * L[i*N+k]* /*conj*/(L[j*N+k]);// –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ-—Å–æ–ø—Ä—è–∂–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ
		if (j == i) {// –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
			L[i*N+j] = (A[i*N+j] - s);
		} else {
			L[i*N+j] = (A[i*N+j] - s)/L[j*N+j];
			L[j*N+i] = 0;// /*conj*/(L[i*N+j]);// –º–æ–∂–Ω–æ –Ω–µ –∑–∞–ø–æ–ª–Ω—è—Ç—å –≤–æ–≤—Å–µ
		}
	}
}

/*!	\brief –ú–µ—Ç–æ–¥ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –•–æ–ª–µ—Ü–∫–æ–≥–æ

–ú–µ—Ç–æ–¥ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –•–æ–ª–µ—Ü–∫–æ–≥–æ - —ç—Ç–æ –º–µ—Ç–æ–¥ —Ä–µ—à–µ–Ω–∏—è –°–õ–ê–£, –≤ –∫–æ—Ç–æ—Ä–æ–º —Å–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –•–æ–ª–µ—Ü–∫–æ–≥–æ –º–∞—Ç—Ä–∏—Ü—ã A, —Ç.–µ. –º–∞—Ç—Ä–∏—Ü–∞ L, –∞ –∑–∞—Ç–µ–º –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è
—Ä–µ—à–µ–Ω–∏–µ x –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–º —Ä–µ—à–µ–Ω–∏–µ–º –¥–≤—É—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π:
L y = b
D z = y
L^T x = z

–£—Å–ª–æ–≤–∏–µ –ø—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç–∏:
‚àô A - –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü—ã.

–ù–µ—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã A –Ω–µ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–∞ –ø—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –º–µ—Ç–æ–¥–∞, –Ω–æ –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –±—É–¥–µ—Ç –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –∏—Å—Ç–∏–Ω–Ω–æ–º—É.

 */
void cholesky_ldl_solve(const float * L, float *z, const float* c)
{
	z[0] = c[0];
	for (int i=1; i<N; i++){//  L y = c
		float s = 0;
		for (int k=0; k<i; k++)
			s = fmaf(L[i*N+k],z[k],s);
		z[i] = c[i] - s;
	}
	for (int i=0; i<N; i++)		// D z = y
		z[i] /= L[N*i+i];
	for (int i=N-2; i>=0; i--){	// U x = z
		float s = 0;
		for (int k=i+1; k<N; k++)// –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∏–∂–Ω—é—é —Ç—Ä–µ—É–≥–æ–ª—å–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É
			s = fmaf(/*conj*/(L[k*N+i]),z[k],s);
		z[i] = z[i] - s;
	}
}
/*! \brief –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–µ—Ç–µ—Ä–º–∏–Ω—Ç–∞ –∏–∑ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è —Ö–æ–ª–µ—Ü–∫–æ–≥–æ

–í —Å–ª—É—á–∞–µ A=LL^T —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –ø–æ–ª—É—á–∞–µ—Ç—Å—è –¥–≤–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ –º–∞—Ç—Ä–∏—Ü—ã
 det(A) = det(L)*det(L^T)
		= \prod_{k=1}^{N} l_{kk}^2
–í —Å–ª—É—á–∞–µ A=LDL^T —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è
 det(A) = \prod_{k=1}^{N} d_{kk}
 */
float cholesky_ldl_det(const float * L){
	float s=0;
	for (int i=0; i<N; i++)
		s *= L[i*N+i];
	return s;
}

/*! –†–∞–∑–¥–µ–ª –ø–æ–ª–∏–Ω–æ–º—ã, —Ö–æ—Ç–∏–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —à–∞–±–ª–æ–Ω –∫–ª–∞—Å—Å–∞ –ø–æ–ª–∏–Ω–æ–º—ã —Å —É—á–µ—Ç–æ–º –∑–∞–º–µ–Ω—ã –æ–ø–µ—Ä–∞—Ü–∏–∏ 
- –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª (–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –¥—Ä–æ–±—å—é –∏–∑ —Ü–µ–ª—ã—Ö –∏ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª).
- –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ —á–∏—Å–µ–ª –≤ –∫–æ–Ω–µ—á–Ω–æ–º –ø–æ–ª–µ —Å –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–æ–π –ì–∞–ª—É–∞ 
- –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ —á–∏—Å–µ–ª –ø–æ –º–æ–¥—É–ª—é –±–æ–ª—å—à–æ–≥–æ —á–∏—Å–ª–∞
- –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª
- –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —á–∏—Å–µ–ª
- –Ω–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ, –∫–æ–≥–¥–∞ —Å—É–º–º–∞ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –¥–∞–µ—Ç –µ–¥–∏–Ω–∏—Ü—É. 
- —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —á–∏—Å–ª–∞, –∫–æ—Ä–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤ –≤–∏–¥–µ –¥—Ä–æ–±–∏ P/Q —Ç–∞–∫, —á—Ç–æ P/M+Q/M =1. 
 */
/*! \brief –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ s = r(x)
	\param a - –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–µ–ø–µ–Ω—è—Ö, a[0]x^n + a[1]x^n-1 + ... + a[n]
 */
static inline float v_poly_eval(const float* a, size_t len_a, float x)
{
	float s = 0;
	for(int i=0; i< len_a; i++)
		s = s*x + a[i];
	return s;
}
/*! \brief –æ–±–Ω—É–ª–µ–Ω–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø–æ–ª–∏–Ω–æ–º–∞
 */
static inline void v_poly_zero(float* r, size_t offs, size_t len){
	for (int i=offs; i< len; i++) r[i]=0;
}
/*! \brief —Å–ª–æ–∂–µ–Ω–∏–µ  –ø–æ–ª–∏–Ω–æ–º–æ–≤ r = r(x) + a(x)
 */
static inline void v_poly_add(float* r, const float* a, size_t len_a){
	for (int i=0; i< len_a; i++) r[i]+=a[i];
}
/*! \brief –≤—ã—á–∏—Ç–∞–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–æ–≤ r = r(x) - a(x)
 */
static inline void v_poly_sub(float* r, const float* a, size_t len_a){
	for (int i=0; i< len_a; i++) r[i]-=a[i];
}
/*! \brief —Å–ª–æ–∂–µ–Ω–∏–µ  –ø–æ–ª–∏–Ω–æ–º–æ–≤ r = r(x) + c a(x)
	\param c - —Å–∫–∞–ª—è—Ä
 */
static inline void v_poly_mac1(float* r, const float* a, size_t len_a, float c){
	for (int i=0; i< len_a; i++) r[i]+=a[i]*c;
}
/*! \brief –≤—ã—á–∏—Ç–∞–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–æ–≤ r = r(x) - c a(x)
	\param c - —Å–∫–∞–ª—è—Ä
 */
static inline void v_poly_mus1(float* r, const float* a, size_t len_a, float c){
	for (int i=0; i< len_a; i++) r[i]-=a[i]*c;
}
/*! \brief –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ —Å–∫–∞–ª—è—Ä r(x) = c a(x)
	\param a - –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–µ–ø–µ–Ω—è—Ö, a[0]x^n + a[1]x^n-1 + ... + a[n]
	\param c - —Å–∫–∞–ª—è—Ä
 */
static inline void v_poly_mul1(float* r, const float* a, size_t len_a, float c){
	for (int i=0; i< len_a; i++) r[i] =a[i]*c;
}
/*! \brief –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–æ–≤ 
	\param a  - –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–µ–ø–µ–Ω—è—Ö, a[0]x^n + a[1]x^n-1 + ... + a[n]
	–°—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞ –Ω–∞ –≤—ã—Ö–æ–¥–µ len_a + len_b -1
 */
void v_poly_mul(float* r, const float* a, size_t len_a, const float* b, size_t len_b)
{
	v_poly_mul1(r, a, len_a, b[0]);
	v_poly_zero(r, len_a, len_a + len_b - 1);
	for (int i=1; i<len_b; i++)
		v_poly_mac1(r+i, a, len_a, b[i]);
}
/*! \brief –¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–æ–≤, –ø–æ–Ω–∏–∂–µ–Ω–∏–µ —Å—Ç–µ–ø–µ–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∞ 
	–ù–∞ –≤—ã—Ö–æ–¥–µ r —Å–æ–¥–µ—Ä–∂–∏—Ç q - —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ–ª–µ–Ω–∏—è –≤ –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏ (len_r - (len_a -1))
	–∏ –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö (len_a-1) —á–∏—Å–ª–∞—Ö
	\param r - –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–µ–ø–µ–Ω—è—Ö
	\param len_r - —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞ r+1, –¥–ª–∏–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞
	\param a - –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø—Ä–∏ —Å—Ç–µ–ø–µ–Ω—è—Ö, a[0]x^n + a[1]x^n-1 + ... + a[n], –≥–¥–µ a[0]=1
	\param len_a - —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞ a+1, –¥–ª–∏–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞ 
 */
void v_poly_div(float* r, size_t len_r, const float* a, size_t len_a)
{
	for (int i=0; i<=(len_r - len_a); i++){
		float q = r[i];
		if (q!=0) 
			v_poly_mus1(r+i, a, len_a, q);
		r[i] = q;
	}
}
/*! \brief –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –º–∞—Ç—Ä–∏—Ü—ã

	–†–µ—à–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –µ—Å–ª–∏ P(r) = det(A - ùúÜI)=0 
	det(A ‚àí ùúÜI) = det(U - ùúÜL^{-1})
	–º–æ–∂–Ω–æ —Å–æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ–ª–∏–Ω–æ–º –∏ –Ω–∞–π—Ç–∏ –∫–æ—Ä–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∞ - —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞ ùúÜ_n.

	–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –∫–æ—Ä–Ω–µ–π –ø–æ–ª–∏–Ω–æ–º–∞...
–û—Å–Ω–æ–≤–Ω–∞—è —Ç–µ–æ—Ä–µ–º–∞ –∞–ª–≥–µ–±—Ä—ã —É—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç, —á—Ç–æ –∫–∞–∂–¥—ã–π –º–Ω–æ–≥–æ—á–ª–µ–Ω –Ω–∞–¥ –ø–æ–ª–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —á–∏—Å–µ–ª 
–ø—Ä–µ–¥—Å—Ç–∞–≤–∏–º –≤ –≤–∏–¥–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –ª–∏–Ω–µ–π–Ω—ã—Ö –º–Ω–æ–≥–æ—á–ª–µ–Ω–æ–≤, –ø—Ä–∏—á—ë–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –æ–±—Ä–∞–∑–æ–º 
—Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –º–Ω–æ–∂–∏—Ç–µ–ª—è –∏ –ø–æ—Ä—è–¥–∫–∞ —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è —Å–æ–º–Ω–æ–∂–∏—Ç–µ–ª–µ–π.
 */
#undef N

/*! –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –Ω–æ—Ä–º—ã —Å—É–º–º—ã –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –æ—Ç –∫–æ–ª–æ–Ω–∫–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã
	\param n - —Ä–∞–∑–º–µ—Ä –≤–µ–∫—Ç–æ—Ä–∞
	\param m - —Ä–∞–∑–º–µ—Ä –ø–æ —à–∏—Ä–∏–Ω–µ, –¥–ª—è –≤–µ–∫—Ç–æ—Ä–æ–≤ —à–∏—Ä–∏–Ω–∞ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è —Ä–∞–≤–Ω–æ–π 1.
	\param off - –Ω–æ–º–µ—Ä —Å—Ç–æ–ª–±—Ü–∞ –º–∞—Ç—Ä–∏—Ü—ã
 */
static float norm_col(const float *a, int m, int n, int j)
{
	float s=0;
	for(int i=0; i<m; i++) s = fmaf(a[i*n + j], a[i*n + j], s);
	return sqrtf(s);
}
/*! –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å–∫–∞–ª—è—Ä–Ω–æ–≥–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –æ—Ç –¥–≤—É—Ö –∫–æ–ª–æ–Ω–æ–∫ –º–∞—Ç—Ä–∏—Ü—ã
	\param m - —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫
	\param n - —á–∏—Å–ª–æ —Å—Ç–æ–ª–±—Ü–æ–≤, m x n —Ä–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã
	\param j - –Ω–æ–º–µ—Ä –∫–æ–ª–æ–Ω–∫–∏
	\param k - –Ω–æ–º–µ—Ä –∫–æ–ª–æ–Ω–∫–∏
 */
static float dot_col(const float *a, int m, int n, int j, int k)
{
	float s=0;
	for(int i=0; i<m; i++) s = fmaf(a[i*n + j], a[i*n + k], s);
	return s;
}
static float dot_row(const float *A, unsigned m, unsigned n, unsigned j, unsigned k)
{
	const float *a = A + n*j;
	const float *b = A + n*k;
	float s=0;
	for(unsigned i=0; i<m; i++) s = fmaf(a[i], b[i], s);
	return s;
}
static
void scal_col(float d, float* a, unsigned M, unsigned N, int k){
	for (int j=0; j<M; ++j)
		a[j*N+k] *= d;
}

/*! \brief –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É */
int  is_symmetric(const float* A, int N){
	for (int i=1; i<N; i++)
		for (int j=0; j<i; j++){// –ø–æ —Å—Ç—Ä–æ–∫–µ
			if (A[i*N+j]!=A[j*N+i]) return 0;
		}
	return 1;
}
/*! \brief –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∞–Ω—Ç–∏-—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É */
int  is_skew_symmetric(const float* A, int N){
	for (int i=1; i<N; i++)
		for (int j=0; j<i; j++){// –ø–æ —Å—Ç—Ä–æ–∫–µ
			if (A[i*N+j]!=-A[j*N+i]) return 0;
		}
	return 1;
}
/*! \brief –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —ç—Ä–º–∏—Ç–æ–≤—É –º–∞—Ç—Ä–∏—Ü—É - –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ —Å–æ–ø—Ä—è–∂–µ–Ω–Ω–∞—è —Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è */
int  is_hermitian(const float* A, int N){
	for (int i=1; i<N; i++)
		for (int j=0; j<i; j++){// –ø–æ —Å—Ç—Ä–æ–∫–µ
			if (/*conj*/(A[i*N+j])!=A[j*N+i]) return 0;
		}
	return 1;
}
/*! \brief –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É 

A square matrix Q is called an orthogonal matrix if it satisfies Q^T Q = I.


 */
int is_orthogonal(const float* A, int N){
	const float eps = N*__FLT_EPSILON__;
	const int M = N;
	for (int j=0; j<N; j++)
	for (int i=0; i<N; i++){
		float s = dot_col(A, M, N, i,j);// dot product column vectors
//		float r = dot_row(A, M, N, i,j);// dot product row vectors
//		if(fabsf(r-s)>=eps) return 0;
		if(i!=j && fabsf(s-0.0f)>=eps) {
			//printf("i,j=%d,%d\n", i,j);
			return 0;
		}
		if(i==j && fabsf(s-1.0f)>=eps) {
			//printf("i,j=%d,%d %1.8f\n", i,j, s);
			return 0;
		}
	}
	return 1;
}
/*! 
	–µ—Å–ª–∏ –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤-—Å—Ç–æ–ª–±—Ü–æ–≤ ‚ÄñA(:,j)‚Äñ = 1
 */
int is_orthonormal(const float* A, unsigned M, unsigned N){
	const float eps = N*__FLT_EPSILON__;
	for (int i=0; i<N; i++){
		float s = norm_col(A, M, N, i);
		if(fabsf(s-1.0f)>=eps) return 0;
	}
	return 1;
}
/*! 
	–º–∞—Ç—Ä–∏—Ü–∞ –Ω–æ—Ä–º–∞–ª—å–∞–Ω—è, –µ—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ª–æ–≤–∏–µ A·µÄ¬∑A = A¬∑A·µÄ. 
	–î–ª—è –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö –º–∞—Ç—Ä–∏—Ü A·¥¥¬∑A = A¬∑A·¥¥.
 */
int is_normal(const float* A, unsigned N){
	const float eps = N*__FLT_EPSILON__;
	const unsigned M = N;
	unsigned i,j,k;
	for (i=0; i<N; i++){
		for (j=0; j<N; j++){
			float s = dot_col(A, M, N, i,j);// dot product column vectors
			float r = dot_row(A, M, N, i,j);
			if(fabsf(r-s)>=eps) return 0;
		}
	}
	return 1;
}
/*! QR- —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã 
	Q - –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è, R- –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è



–°–≤–æ–π—Å—Ç–≤–æ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã $Q^T Q = I$
–û—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –Ω–æ—Ä–º—É |Qx| = |x|

 Any nonsingular matrix A can be factored, A = QR, into the product
of an orthogonal matrix Q and an upper triangular matrix R. The factorization is unique
if all the diagonal entries of R are assumed to be positive.

<https://www-users.cse.umn.edu/~olver/aims_/qr.pdf>

Theorem 5.1. Any nonsingular matrix A can be factored, A = QR, into the product of 
an orthogonal matrix Q and an upper triangular matrix R. 
The factorization is unique if all the diagonal entries of R are assumed to be positive.

Algorithm 5.2.6 (Modified Gram-Schmidt) This algorithm requires 2mn2 flops. 
A \in R^{m \times n} 
R \in R^{n \times n} upper triangular
*/

int qr_decomp(float* a, float* r, unsigned M, unsigned N)
{
	float d;
	unsigned i,j,k;
	for(j=0; j<N;j++){// –ø–æ –∫–æ–ª–æ–Ω–∫–∞–º
		for (k=0; k<j; k++) r[j*N+k] = 0;
		r[j*N+j] = d = norm_col(a, M, N, j);
		//if (r[j*N+j]==0) return j;// –ª–∏–Ω–µ–π–Ω–æ –∑–∞–≤–∏—Å–∏–º–∞—è –∫–æ–ª–æ–Ω–∫–∞
		if (d!=0) scal_col(1/d, a, M ,N, j);
		for (k=j+1; k<N; k++) {
			r[j*N+k] = d = dot_col(a, M, N, j, k);
			for (i=0; i<M; i++) // column(k)-= u(j)*(a_j^T a_k)// y = y -d x
				a[i*N+k] -= a[i*N+j]*d;
		}
	}
	return -1;
}
/*! \brief QR- —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã (–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞)

	Q - –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è, R- –≤–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è

Algorithm 5.2.7 (Classical Gram-Schmidt)  [Golub & van Loan]
*/
int qr_cgs_decomp(float* a, float* r, unsigned M, unsigned N)
{
	float d;
	r[0*N+0] = d = norm_col(a, M, N, 0);
	if (d!=0.0f) scal_col(1/d, a, M ,N, 0);
	for (int k=1; k<N; ++k){
		for (int i=0; i<k; ++i)  // R(1:k‚àí1, k) = Q(1:m, 1:k‚àí1)^T A(1:m, k)
			r[i*N+k] = dot_col(a, M, N, i, k);
		for (int j=0; j<M; ++j){
			float s = 0;
			for (int i=0; i<k; ++i)
				s = fmaf(a[j*N+i],r[i*N+k],s);
			a[j*N+k] -= s;
		}
		r[k*N+k] = d = norm_col(a, M, N, k);
		scal_col(1/d, a, M ,N, k);
	}
	return 0;
}
static inline
float givens(float a, float b, float*c, float*s){
	float r = sqrtf(a*a + b*b);
	float d = 1.0f/r;
	*c =  a*d; *s = b*d;
	return r;
}
/* \see Golub & van Loan. 5.1.9 Applying Givens Rotations

–Ø –Ω–µ–º–Ω–æ–≥–æ –¥–æ—Ä–∞–±–æ—Ç–∞–ª –∞–ª–≥–æ—Ä–∏—Ç–º, –ø–æ–º–µ–Ω—è–ª –∑–Ω–∞–∫ —Å–∏–Ω—É—Å–∞ –∏ —Ü–∏–∫–ª —Å—Ç–∞–ª –Ω–µ –æ—Ç –Ω—É–ª—è
*/
static 
void givens_left (float* a, float* r, unsigned  N, unsigned i, unsigned k, float c, float s, float v){
	a[i*N+i] = v;
	a[k*N+i] = 0;
	for (unsigned j=i+1; j < N; ++j){// —Ü–∏–∫–ª –ø–æ —Å—Ç—Ä–æ–∫–µ
		float t1 = a[i*N+j];
		float t2 = a[k*N+j];
		a[i*N+j] = c*t1 + s*t2;
		a[k*N+j] = c*t2 - s*t1;
	}
}
static 
void givens_right(float* a, unsigned N, unsigned i, unsigned k, float c, float s, float r){
	a[i*N+i] = r;
	a[i*N+k] = 0;
	for (unsigned j=i+1; j < N; ++j){// —Ü–∏–∫–ª –ø–æ —Å—Ç–æ–ª–±—Ü—É –º–∞—Ç—Ä–∏—Ü—ã
		float t1 = a[j*N+i];
		float t2 = a[j*N+k];
		a[j*N+i] = c*t1 + s*t2;
		a[j*N+k] = c*t2 - s*t1;
	}
}

/*! –ü–æ–ª—É—á–µ–Ω–∏–µ QR —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–º –≤—Ä–∞—â–µ–Ω–∏—è –ì–∏–≤–µ–Ω—Å–∞ 
–¥–æ–¥–µ–ª–∞—Ç—å Q = 
 */
int qr_givens(float* a, float* r, unsigned M, unsigned N)
{
	float c,s;
	for (int i=1; i < M; ++i){// –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏
		for (int j=0; j < i; ++j){// –Ω–æ–º–µ—Ä —Å—Ç–æ–ª–±—Ü–∞ x
			//if (a[i*N+j]==0) continue;
			float v = givens(a[j*N+j], a[i*N+j], &c,&s);
			givens_left(a, r, N, j, i, c, s, v);
			printf("[%d;%d]\n", i,j);
			print_mn(a, M, N);
		}
	}
	return 0;
}

typedef float Ftype;
typedef struct _vector vector_t;
typedef struct _matrix matrix_t;
struct _vector {
	unsigned N;
	unsigned stride;
	Ftype * data;
};
struct _matrix {
	unsigned M,N;
	unsigned lda;
	Ftype * data;
};
static inline
matrix_t _submatrix(Ftype* a, unsigned i, unsigned j, unsigned M, unsigned N, unsigned lda){
	matrix_t m = {.lda = lda, .M = M, .N = N, .data = a + i*lda + j};
	return m;
}
/*! –∫–ª–∞—Å—Å –≤–µ–∫—Ç–æ—Ä - —ç—Ç–æ —Ç–æ —á—Ç–æ –≤—ã–¥–µ–ª–µ–Ω–æ –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã (–ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ –∫–æ–ª–æ–Ω–∫–∞)*/
static inline
vector_t _subrow(Ftype* a, unsigned i, unsigned j, unsigned size, unsigned N){
	vector_t v = {.data = a+i*N+j, .N = size, .stride = 1};
	return v;
}
static inline
vector_t _subcolumn(Ftype* a, unsigned i, unsigned j, unsigned size, unsigned N){
	vector_t v = {.data = a+i*N+j, .N = size, .stride = N};
	return v;
}
/*! –≤—ã–¥–µ–ª–∏—Ç—å –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã */
static inline
vector_t _diag(Ftype* a, unsigned i, unsigned j, unsigned size, unsigned N){
	vector_t v = {.data = a+i*N+j, .N = size, .stride = N+1};
	return v;
}

static inline
vector_t _subvector(Ftype* x, unsigned i, unsigned size, unsigned N){
	vector_t v = {.data = x+i*N+0, .N = size, .stride = N};
	return v;
}
static inline
void  _vector_set(vector_t *v, unsigned i, Ftype value){
	v->data[i*v->stride] = value;
}
static inline
Ftype _vector_get(vector_t *v, unsigned i, Ftype value){
	return v->data[i*v->stride];
}
static inline
Ftype _vector_exchange(vector_t *v, unsigned i, Ftype value){
	Ftype *r = v->data+i*v->stride;
	Ftype vi = *r;
	*r = value;
	return vi;
}
void _set_identity(Ftype* a, unsigned M, unsigned N){
	for (unsigned i=0; i<M; ++i)
	for (unsigned j=0; j<N; ++j)
		a[i*N+j] = 0;
	if (N>M) N = M;
	for (unsigned i=0; i<N; ++i)
		a[i*N+i] = 1;
}

#define BLAS(n) cblas_##n
#define CblasNoTrans 0
#define CblasTrans 	 1
static 
Ftype  BLAS(nrm2)(const Ftype *v, unsigned N, unsigned stride){
	double sum = 0.0f;
	for (unsigned i=0; i<N; ++i)
		sum += v[i*stride]*v[i*stride];
	return sqrtf(sum);
}
static 
Ftype  BLAS(asum)(const Ftype *v, unsigned N, unsigned stride){
	double sum = 0.0f;
	for (unsigned i=0; i<N; ++i)
		sum += fabsf(v[i*stride]);
	return sum;
}
static 
void   BLAS(scal)(Ftype s,  Ftype *v, unsigned N, unsigned stride){
	for (unsigned i=0; i<N; ++i) v[i*stride] *= s;
}
static 
void   BLAS(axpy)(Ftype alpha, const Ftype *x, int dx, 
Ftype *y, int dy, unsigned N){
	for (unsigned i=0; i<N; ++i)
		y[i*dy] += alpha*x[i*dx];
}
static 
void   BLAS(lerp)(const Ftype *mu, int dm, const Ftype *x, int dx, 
Ftype *y, int dy, unsigned N){
	for (unsigned i=0; i<N; ++i)
		y[i*dy] += mu[i*dm] * (x[i*dx] - y[i*dy]);
}
static 
void  BLAS(ger)(Ftype beta, const Ftype *X, int dx, const Ftype*Y, int dy, 
Ftype*A, int lda, unsigned M, unsigned N)
{
    for (unsigned j = 0; j < M; j++) {
      const Ftype tmp = beta * Y[j*dy];
      for (unsigned i = 0; i < N; i++)
        A[i + lda * j] += X[i*dx] * tmp;
    }
}
static
void BLAS(gemv)(Ftype beta,  Ftype* Y, int dy,
Ftype alpha, Ftype* X, int dx,
Ftype*A, int lda, unsigned M, unsigned N, int Trans)
{
	unsigned lenX, lenY;
  if (Trans == CblasNoTrans) {
    lenX = N;
    lenY = M;
  } else {
    lenX = M;
    lenY = N;
  }
	if (beta==0.0f){
		for (unsigned i=0; i< lenY; i++) Y[i*dy] = 0;
	} else if (beta!=1.0f){
		for (unsigned i=0; i< lenY; i++) Y[i*dy]*= beta;
	}
	if (alpha==0.0) return;
  if (Trans == CblasTrans){ /* form  y := alpha*A'*x + y */
    for (unsigned j = 0; j < lenX; j++) {
      const Ftype temp = alpha * X[j*dx];
      if (temp != 0.0) {
        for (unsigned i = 0; i < lenY; i++)
          Y[i*dy] = fmaf(temp , A[lda * j + i], Y[i*dy]);
      }
    }		
  } else {/* form  y := alpha*A*x + y */
    for (unsigned i = 0; i < lenY; i++) {
      Ftype temp = 0.0;
      for (unsigned j = 0; j < lenX; j++)
        temp = fmaf(X[j*dx], A[lda * i + j], temp);
      Y[i*dy] += alpha * temp;
    }
  }
}

#define GSL_SIGN(x)    ((x) >= 0.0 ? 1 : -1)
static 
Ftype house (Ftype *v, int N, unsigned stride){
	if (N==1) return 0.0f;
	Ftype vdot=0;
	for(unsigned i=1; i< N;++i) vdot = fmaf(v[i*stride], v[i*stride],vdot);// nrm2
//	if (norm==0.0f) return 0.0f;
	Ftype alpha = v[0];
	Ftype beta = GSL_SIGN(alpha)*sqrtf(alpha*alpha+vdot);//sqrtf(alpha*alpha + norm*norm);
	Ftype s  =(alpha+beta);
	v[0] = -beta;
	if (s!=0.0f) for(unsigned i=1; i< N;++i) v[i*stride] /= s;// scal
	return (alpha+beta)/beta;
}
static
void house_mh  (Ftype beta, vector_t* v, matrix_t* A){
	if (beta==0.0f) return;
	unsigned i, j, k, M = A->M, N = A->N, lda = A->lda;
	for (i = 0; i < M; i++){
		Ftype w = A->data[i*lda+0];
		for (j=1; j<N; j++) // sdot
			w = fmaf(A->data[i*lda+j],v->data[v->stride*j], w);
		w *= -beta;
		A->data[i*lda+0] += w;
		for (j=1; j<N; j++) /* A = A - tau w v' */
			A->data[i*lda+j] += w*v->data[v->stride*j];
	}
}
static
void house_hm  (Ftype beta, vector_t* v, matrix_t* A){
	if (beta==0.0f) return;
	unsigned i, j, k, M = A->M, N = A->N, lda = A->lda;
	for (j = 0; j < N; j++){
		Ftype w = A->data[0*lda+j];
		for (k=1; k<M; k++) // sdot
			w = fmaf(A->data[k*lda+j],v->data[v->stride*k],w);
		w *= -beta;
		A->data[0*lda+j] += w;
		for (i=1; i<M; i++) /* Aij = Aij - tau vi wj */
			A->data[i*lda+j] = fmaf(w,v->data[v->stride*i], A->data[i*lda+j]);
	}
}
static
void house_left(Ftype beta, vector_t* v, matrix_t* A,  vector_t* w){

	if (beta==0.0f) return;
	Ftype v0 = v->data[0]; v->data[0] = 1.0f;
#if 1
	BLAS(gemv)(0.0f, w->data, w->stride, 1.0f, v->data, v->stride, A->data, A->lda, A->M, A->N, CblasTrans);// w = A^T v
	BLAS(ger) (-beta, w->data, w->stride, v->data, v->stride, A->data, A->lda, A->M, A->N); //A = A - beta v (v^T A) = A - beta v (A^T v)^T
#else // –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è BLAS
	const unsigned M = A->M;
	const unsigned N = A->N;
	const unsigned lda = A->lda;
	for (int k=0;k<N; k++){
		Ftype s = 0;
		for (int i=0;i<M; ++i){
			s += A->data[i*lda+k]*v->data[i*v->stride];
		}
		w->data[k*w->stride] = s;
	}
	for (int i=0;i<M; ++i){
		Ftype d = -beta*v->data[i*v->stride];
		for (int k=0;k<N; k++)
			A->data[i*lda+k] += d*w->data[k*w->stride];
	}
#endif
	v->data[0] = v0;
}
static
void house_right(Ftype beta, vector_t* v, matrix_t* A,  vector_t* w){
	if (beta==0.0f) return;
	Ftype v0 = v->data[0]; v->data[0] = 1.0f;
	BLAS(gemv)(0.0f, w->data, w->stride, 1.0f, v->data, v->stride, 
	A->data, A->lda, A->M, A->N, CblasNoTrans);// w = A^T v
	BLAS(ger) (-beta, w->data, w->stride, v->data, v->stride, A->data, A->lda, A->M, A->N); 
	//A = A - beta v (v^T A) = A - beta v (A^T v)^T
	v->data[0] = v0;
}
/*! \brief QR —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –æ—Ç—Ä–∞–∂–µ–Ω–∏—è –•–∞—É—Å—Ö–æ–ª–¥–µ—Ä–∞ */
int qr_house(Ftype * a, Ftype * tau, unsigned M,  unsigned N)
{
	const unsigned lda = N;
	for (int j=0; j< N; ++j){
		vector_t v = _subcolumn(a, j, j, M-j, lda);
		Ftype tau_j = house(a+lda*j+j, M-j, lda);
		tau[j] = tau_j;
		if (j+1<M){
			vector_t w = _subvector(tau,  j+1, N-(j+1), 1);
			matrix_t m = _submatrix(a, j, j+1, M-j, N-(j+1), lda);
			house_left(tau_j, &v, &m, &w);
		}
	}
	return 0;
}
static 
void BLAS(gemm)(int flags,  Ftype alpha, matrix_t* A, matrix_t* B, Ftype beta, matrix_t* Y){
	unsigned i,j,k;
	const unsigned M = Y->M;
	const unsigned N = Y->N;
	const unsigned L = B->M;
	if (flags == CblasTrans){
		for (i=0; i<M; i++)
		for (j=0; j<N; j++){
			float s=0;
			for (k=0; k<L; k++)
				s += A->data[k*A->lda+i]*B->data[k*B->lda+j];
			Y->data[i*Y->lda+j] = beta*Y->data[i*Y->lda+j] + alpha*s;
		}
	} else {
		for (i=0; i<M; i++)
		for (j=0; j<N; j++){
			float s=0;
			for (k=0; k<L; k++)
				s += A->data[i*A->lda+k]*B->data[k*B->lda+j];
			Y->data[i*Y->lda+j] = beta*Y->data[i*Y->lda+j] + alpha*s;
		}
	}
}
#if 1
/*! \brief –±–ª–æ—á–Ω—ã–π —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º 
	\param a –º–∞—Ç—Ä–∏—Ü–∞ MxN
	\param r –º–∞—Ç—Ä–∏—Ü–∞ NxN
	\return 0 - –µ—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–µ–Ω
	\see Golub & van Loan. Algorithm 5.2.3 (Recursive Block QR)
 */
int qr_block(matrix_t* a, matrix_t* r)
{
	const unsigned Nb= 2; 
	const unsigned M = a->M;
	const unsigned N = a->N;
	
//	ASSERT(N==r->sz[0]);
//	ASSERT(N==r->sz[1]);
	if (N<=Nb) // –ø–æ—Ä–æ–≥ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –ª–∏–Ω–µ–π–Ω–æ–º—É –∞–ª–≥–æ—Ä–∏—Ç–º—É
		return qr_decomp(a->data, r->data, M, N);
	const size_t N1 = N/2;// SPLIT(N)
	matrix_t A1 = _submatrix(a->data, 0,  0, M,   N1, a->lda);
	matrix_t A2 = _submatrix(a->data, 0, N1, M, N-N1, a->lda);
	matrix_t R11= _submatrix(r->data, 0,  0,   N1,  N1, r->lda);
	matrix_t R12= _submatrix(r->data, N1, 0, N-N1,  N1, r->lda);
	matrix_t R22= _submatrix(r->data, N1,N1, N-N1,N-N1, r->lda);
	qr_block(&A1, &R11);
	BLAS(gemm)(CblasTrans,    1, &A1, &A2, 0, &R12); // R_{12} = Q_1^T A_2
	BLAS(gemm)(CblasNoTrans, -1, &A1, &R12,1, &A2); //  A_2  = A2 - Q_1 R_{12}
	qr_block(&A2, &R22);
	return 0;
}
#endif
int qr_house_bidi(Ftype * a, Ftype * tau, Ftype * tav, unsigned M,  unsigned N)
{
	const unsigned lda = N;
	for (int j=0; j< N; ++j){
		vector_t v = _subcolumn(a, j, j, M-j, lda);
		Ftype tau_j = house(a+lda*j+j, M-j, lda);
		
		vector_t w = _subvector(tau,  j+1, N-(j+1), 1);
		matrix_t m = _submatrix(a, j, j, M-j, N-j, lda);
		house_left(tau_j, &v, &m, &w);

		if (j+2<=N){
			vector_t v = _subrow(a, j,  j+1, N-j,   1);
			Ftype tau_j = house(a+lda*j+j+1, N-j-1, 1);

			vector_t w = _subvector(tav,  j+1, N-(j+1), 1);
			matrix_t m = _submatrix(a, j, j+1, M-j, N-(j+1), lda);
			house_right(tau_j, &v, &m, &w);
			
		}
	}
}
/*! \brief –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–∞—Ç—Ä–∏—Ü—É Q –∏ R –∏–∑ –∫–æ–º–ø–∞–∫—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ QR —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è, 
–ø–æ–ª—É—á–µ–Ω–Ω–æ–π –º–µ—Ç–æ–¥–æ–º –≤—Ä–∞—â–µ–Ω–∏–π –•–∞—É—Å—Ö–æ–ª–¥–µ—Ä–∞ 
	\param r - –º–∞—Ç—Ä–∏—Ü–∞ R –º–æ–∂–µ—Ç –±—ã—Ç—å NULL
*/
int qr_house_unpack(Ftype * a, Ftype * tau,  Ftype * q, Ftype * r, unsigned M,  unsigned N){
	unsigned i,j,k;
	unsigned lda = N;
	_set_identity(q, M, N);
	for (j=N; j-- >0;){
		vector_t v = _subcolumn(a, j, j, M-j, lda);
		matrix_t m = _submatrix(q, j, j, M-j, N-j, lda);
		house_hm(tau[j], &v, &m);
	}
	if (r!=NULL){
		for (i=0; i<M; ++i){
			for (j = 0; j < i && j < N; j++)
				r[i*N+j] = 0;
			for (j = i; j < N; j++)
				r[i*N+j] = a[i*lda+j];
		}
	}
}

/*! \brief —Ä–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —É—Ä–∞–≤–Ω–µ–Ω–∏–π Ax=b –º–µ—Ç–æ–¥–æ–º QR 
	\param a –º–∞—Ç—Ä–∏—Ü–∞ M x N –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ R, –≤–µ—Ä—Ö–Ω—é—é —Ç—Ä–µ—É–≥–æ–ª—å–Ω—É—é
	\param x –≤–µ–∫—Ç–æ—Ä —Ä–∞–∑–º–µ—Ä–æ–º M –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–∞ –≤—Ö–æ–¥–µ `b`, –Ω–∞ –≤—ã—Ö–æ–¥–µ `x`
 */
int qr_house_svx(Ftype * a, Ftype * x, unsigned M,  unsigned N){
	for (unsigned i=0; i<N; i++){
		Ftype aii = a[i*N+i];
		Ftype r=0;
		for (unsigned k=i+1; k<M; k++){// –Ω–æ—Ä–º–∞ (dot) –≤–µ–∫—Ç–æ—Ä–∞ A(i+1:m, i)
			Ftype aki = a[k*N+i];
			r += aki*aki;
		}
		if (r==0.0f) return i;
		r += aii*aii;// v^T v
		Ftype alpha = copysignf(sqrtf(r),aii);//*GSL_SIGN(aii); 
		Ftype ak = 1.0f/(r+alpha*aii);
		
		a[i*N+i] = aii+alpha;
		for (unsigned k = i + 1; k < N; k++){
			Ftype f =0;
			for (unsigned j = i; j < M; j++)// —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ dot_col(a, k, i)
				f += a[j*N+k]*a[j*N+i];
			f *= ak;
			for (unsigned j = i; j < M; j++)
				a[j*N+k] -= f*a[j*N+i];
		}
		/* Perform update of right-hand side `b` */
		Ftype f = 0;
        for (unsigned j = i; j < M; j++)
        	f += x[j] * a[j*N+i];
		f *= ak;
		for (unsigned j = i; j < M; j++)
			x[j] -= f*a[j*N+i];

		a[i*N+i] =-alpha;
	}
    /* Perform back-substitution. */

    for (unsigned i = N; i-- > 0;)
    {
        Ftype sum = 0.0;
        for (unsigned k = i + 1; k < N; k++)
            sum += a[i*N+k] * x[k];
        x[i] = (x[i] - sum) / a[i*N+i]; // d[i] = -alpha_i
    }
}
/*! \brief QR —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –æ—Ç—Ä–∞–∂–µ–Ω–∏—è –•–∞—É—Å—Ö–æ–ª–¥–µ—Ä–∞ (2)
	\param a - –º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞–∑–º–µ—Ä–æ–º M x N –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç QR -—Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è,
	–≥–¥–µ R - –í–µ—Ä—Ö–Ω—è—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞, –∞ –Ω–∏–∂–Ω—è—è —á–∞—Å—Ç—å —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ–∫—Ç–æ—Ä–∞ –•–∞—É—Å—Ö–æ–ª–¥–µ—Ä–∞.
	\param tau - –≤–µ–∫—Ç–æ—Ä —Ä–∞–∑–º–µ—Ä–æ–º N –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
	\param M - —á–∏—Å–ª–æ —Å—Ç—Ä–æ–∫
	\param M - —á–∏—Å–ª–æ —Å—Ç–æ–ª–±—Ü–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã
 */
int qr_house2(Ftype * a, Ftype* tau, unsigned M,  unsigned N)
{
	unsigned i,j,k;
	for (i=0; i<N; i++){
		Ftype aii = a[i*N+i];
		Ftype r=0;
		for (k=i+1; k<M; k++){// –Ω–æ—Ä–º–∞ (dot) –≤–µ–∫—Ç–æ—Ä–∞ A(i+1:m, i)
			Ftype aki = a[k*N+i];
			r += aki*aki;
		}
		if (r==0.0f) return i;
		r += aii*aii;// v^T v
		Ftype alpha = copysignf(sqrtf(r),aii);//*GSL_SIGN(aii); 
		Ftype ak = 1.0f/(r+alpha*aii);
		a[i*N+i] = aii+alpha;
		tau[i]   = (aii+alpha)/alpha;
		for (k = i + 1; k < N; k++){
			Ftype f =0;
			for (j = i; j < M; j++)// —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ dot_col(a, k, i)
				f += a[j*N+k]*a[j*N+i];
			f *= ak;
			for (j = i; j < M; j++)
				a[j*N+k] -= f*a[j*N+i];
		}
		Ftype s  = a[i*N+i];
		a[i*N+i] =-alpha; // –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤–µ—Ä—Ö–Ω–µ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã
		/* —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–µ–∫—Ç–æ—Ä –•–∞—É—Å—Ö–æ–ª–¥–µ—Ä–∞ (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ). 
		   –ù–∏–∂–Ω—è—è —É–Ω–∏—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–µ–∫—Ç–æ—Ä–∞ {1.0, v[j+1:m]} */
		if (s!=0.0f) for (k = i + 1; k < N; k++) 
			a[k*N+i] /=s;
	}
	return 0;
}
/*! Algorithm 5.3.2 (Householder LS Solution)

Use Algorithm 5.2.1 to overwrite A with its QR factorization.
 */
void ls_house(Ftype * a, Ftype* tau, Ftype* b, unsigned M,  unsigned N)
{
	for (int j=0; j<N;++j){
		vector_t v = _subcolumn(a, j, j, M-j, N);
		Ftype v0 = _vector_exchange(&v, 0, 1.0f);
		Ftype beta = tau[j];
		_vector_set(&v, 0, v0);
	}
}
#if 0
/*! –†–µ—à–µ–Ω–∏–µ –°–õ–ê–£ Ax=b —á–µ—Ä–µ–∑ QR 
	Q^T QRx = Q^T b => Rx = Q^T b
 */
/*! –°–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü
	
 */
/*! \brief –ë–∏–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ 


	–ß–∏—Å–ª–æ –æ–ø–µ—Ä–∞—Ü–∏–π 4mn^2 ‚àí 4n^3/3 flops
	\see Golub & Van Loan, Matrix Computations (3rd ed.).
 */
int qr_bidiag_decomp (matrix_t * A, vector_t * tau_U, vector_t * tau_V)
{
//	ASSERT(   A->sz[0] >= A->sz[1]);
//	ASSERT(tau_U->size == A->sz[1]);
//	ASSERT(tau_V->size == A->sz[1]);
	const size_t M = A->sz[0];
	const size_t N = A->sz[1];
	gsl_vector * tmp = _vector_alloc(M);

	for (size_t j = 0 ; j < N; j++)
	{	/* apply Householder transformation to current column */
		vector_t v = _matrix_subcolumn(A, j, j, M - j);
		float tau_j = house (&v);

		if (j + 1 < N) {/* apply the transformation to the remaining columns */
			matrix_t m = _matrix_submatrix (A, j, j + 1, M - j, N - j - 1);
			vector_t w = _vector_subvector(tau_U, j, N - j - 1);
			house_left (tau_j, &v, &m, &w);
		}
		_vector_set (tau_U, j, tau_j);            
		if (j + 1 < N) {/* apply Householder transformation to current row */
			v = _matrix_subrow (A, j, j + 1, N - j - 1);
			tau_j = house (&v);
			if (j + 1 < M) {/* apply the transformation to the remaining rows */
                matrix_t m = _matrix_submatrix(A, j + 1, j + 1, M - j - 1, N - j - 1);
                vector_t w = _vector_subvector(tmp, 0, M - j - 1);
				house_right(tau_j, &v, &m, &w);
			}
			_vector_set (tau_V, j, tau_j);
		}
	}
    _vector_free(tmp);
	return 0;
}
#endif