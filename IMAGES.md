# Цифровая обработка изображений #

Введение. Откуда берется изображение
1. Фильтр Байера, преобразование матрицы GRGB изображения с целью выравнивания координат пикселей.
2. Субпиксельная обработка форматов Luma-Croma, YUV, YcrCb, CMYK и т. п. Какие бывают и как их обрабатывать.
3. Растеризация векторных изображений контуров — субпиксельная обработка под матрицу пикселей.
4. Масштабирование изображения без искажений, антиалиасинг.
5. Поворот изображения. 
6. Интерполяция сплайнами, билинейная интерполяция, биквадратная...
7. Интерполяция квадратичными кубическими сплайнами Безье, B-сплайны. 
7.1. Операции со сплайнами: разбиение на два сплайна, представление дуг окружностей сплайнами, разбиение в производной в точке сплайна.
7.2 Матрицы трансформации изображений — масштабируемая векторная графика
8. Интерполяция полиномами Лагранжа, двумерная интерполяция,
8.1 Построение весовых коэффициентов по матрице 4х4
9. Цифровые FIR фильтры для сглаживания и выделения границ изображений
10. Реализация функций ЦОИ на языке OpenCL C, обработка изображений с камеры. 
11. Корреляционные функции — выделение движущихся объектов на изображении. Оценка движения и предсказание движения.
12. Анимация векторных изображений

<!-- для просмотра рекомендуется VSCode в режиме Markdown Preview -->

**Сканирование строк**. Мы будем говорить про дискретные алгоритмы и применять их к обработке изображений по пикселям. Сканирование - векторная операция типа цикл по всем пикселям исходного или конечного изображения. 

1. Пиксель имеет форму квадрата. 
2. Пиксели образуют матрицу $W \times H$. 
3. Изображение состоит из пикселей. Каждый пиксель содержит компоненты цвета.
4. Изображение проецируется с использованием матрицы Аффинного преобразования. 
Матрица преобразования задается параметрами: масштаб, угол поворота ($\theta$) относительно выбранной точки отсчета $(dx,dy)$. 

Изображению соответствует цветовая схема RGB, sRGB или YCC. Реже встречаются схемы CMYK, LMS, XYZ. 

Цвет состоит из трех или четырех компонент. Четвертая компонента цвета - прозрачность - Alpha.Изображения могут быть черно-белые (одна компонента цвета - luminance), содержать одну компоненту цвета. Векторные изображения строятся (rendering) только с компонентой прозрачность (Alpha). С использованием выбранного цвета, изображение накладывается на фоновое через трафарет- прозрачность пикселя.

Формат хранения компонент цвета: float, float16, uint8, uint16

Мы используем методы
* `Affine(M, x,y)` - аффинное преобразование точки (x,y)
* `pixel(Img, x, y)` - чтение пикселя с заданными координатами
* `clamp(x, min, max)` - функция ограничения результата.
* `mix(a,b,t)` - функция смешивания, сплайн 1й степени $t \in [0,1]$;
* `floor(x)` -  целая часть числа $x \in \mathbb{R}$;
* `frac(x)` - дробная часть числа $[0,1)$;

```cpp
foreach ((x,y) in Image1)
    (rx,ry) = Affine(M, x,y);   // аффинное преобразование
// результат преобразования - вектор (rx,ry)
    float ex = (rx - floor(rx));// дробная часть
    float ey = (ry - floor(ry));// 
    unsigned x2 = floor(rx);    // целая часть
    unsigned y2 = floor(ry); 
// отношение площадей:
    s00 = (1-ex)*(1-ey); s01 = (1-ex)*ey; 
    s10 =    ex *(1-ey); s11 =    ex *ey; 
// цвет распределяется между соседними пикселями
    c = pixel(x,y).color;
    Img[x2,   y2  ] += c * s00;
    Img[x2+1, y2  ] += c * s10;
    Img[x2,   y2+1] += c * s01;
    Img[x2+1, y2+1] += c * s11;
```

В результате получается матрица вещественных чисел Img, которую надо наложить на пиксели фонового изображения.
```cpp
foreach ((x, y) in Image2)
    Image2.pixel(x, y).color = clamp(Img[x,y], 0, 255);
```

Мы тут использовали операцию типа SET - запись изображения без смешивания цвета. Ниже будем рассматривать и другие операции с цветом и прозрачностью пикселя. 

## Адресация пикселей в изображении

Положим (x,y) - координаты пикселя в вещественных числах. Изображение представлено массивом пикселей. Цвет пикселя за пределами изображения дается как цвет ближайшего пикселя в пределах изображения. Координаты в пределах изображения:
```c
i = clamp(floor(x), 0, width -1);
j = clamp(floor(y), 0, height-1);
color = Img[j*width + i];
```
Альтернативно может использоваться метод округления к ближайшему целому.
```c
i = clamp(floor(x+0.5), 0, width -1);
j = clamp(floor(y+0,5), 0, height-1);
color = Img[j*width + i];
```

При вычислении компонент цвета пикселей в промежуточных точках, используется билинейная интерполяция по матрице 2x2: 
```math
\begin{aligned}
C_0(x,y) &= (1-e_x) C_{i,j}   + e_x \cdot C_{i+1,j} \\
C_1(x,y) &= (1-e_x) C_{i,j+1} + e_x \cdot C_{i+1,j+1} \\
C (x,y)  &= (1-e_y) C_0(x,y)  + e_y \cdot C_1(x,y)
\end{aligned}
```
$e_x$, $e_y$ - остатки при округлении координат.
```c
float ex = frac(x); // дробная часть числа
float ey = frac(y);
```

билинейная интерполяция - основа субпиксельной обработки. 
Функция `subpixel(x,y)` возвращает результат билинейной интерполяции.

## Поворот изображения

Сканирование изображения может выполняться с использованием аффинного преобразования
```math
\begin{aligned}
x' &=& \cos{\theta} \cdot x - \sin{\theta} \cdot y + dx; \\
y' &=& \sin{\theta} \cdot x + \cos{\theta} \cdot y + dy; \\
\end{aligned}
```
которое описывается матрицей поворота и вектором смещения точки отсчета, вокруг которой выполняется вращение.
```math
\left[
\begin{matrix} 
x'\\ 
y'
\end{matrix}\right]  = \left[
\begin{matrix} 
\cos{\theta} & -\sin{\theta} \\
\sin{\theta} & \cos{\theta} \\
\end{matrix}\right] \left[
\begin{matrix} 
x\\ 
y
\end{matrix}\right] + \left[
\begin{matrix} 
dx\\ 
dy
\end{matrix}\right]
```

Для формирования изображения используется сканирование по строчкам и столбцам конечного изображения, приращение координат на каждом шаге можно определить через угол поворота: 
```math
\begin{aligned}
\Delta{x'} &=& \cos{\theta}; \\
\Delta{y'} &=& \sin{\theta}; \\
\end{aligned}
```
На каждом шаге происходит увеличение дискретных координат исходного изображения с компенсацией ошибки округления. Величина $e_x, e_y$ представляет собой дробную часть числа, которая участвует в билинейной интерполяции. 
```c
for (int i=0; i<width; i++){
    ex += cos_theta;
    if (ex >= 1.0) {
        ex -= 1.0
        xp ++;
    }
    ey += sin_theta;
    if (ey >= 1.0) {
        ey -= 1.0
        yp ++;
    }
}
```
Алгоритм годится для первого квадранта, когда $0 \leqslant \sin{\theta}, 0 \leqslant \cos{\theta}$ 
```c
for (int i=0; i<width; i++){
    ex -= cos_theta;
    if (ex <  0.0) {
        ex += 1.0
        xp --;
    }
    ey += sin_theta;
    if (ey >= 1.0) {
        ey -= 1.0
        yp ++;
    }
}
```
-- для второго квадранта. Аналогично для третьего и четвертого. 

Всего получается четыре варианта сканирования для каждого квадранта. 

Углы и ошибки можно выражать в числах с фиксированной точкой, также как для вещественных, где за единицу принимается $2^M$. 
Тогда операции 
```c
for (int i=0; i<width; i++){
    x += cos_theta;
    y += sin_theta;
    xp = floor(x);
    yp = floor(y);
    ex = frac(x);
    ey = frac(y);
}
```
Для чисел с фиксированной точкой:
```c
#define MASK (~0U<<M)
floor(x) = x >> M;
frac(x)  = x & ~MASK; // маска дробной части
```

## Масштабирование изображений - сжатие

Сначала мы рассмотри каким методом сжать изображение по одной оси.
Мы используем итерационный алгоритм работающий в дробных числах A/B где B- ширина изображения исходного, A - ширина изображения конечного.

Алгоритм можно записать в целых числах:
```c
do {
    color = pixel(x,y);
    ex += A;
    if (ex >= B) {
        ex -= B;
        Im[x1] += (A-ex) * color;
        x1 = x1+1;
        Im[x1]  = ex * color;
    } else
        Im[x1] += A * color;
    x = x+1;
} while (x < W);
```
Алгоритм возвращает строку. По второй оси алгоритм будет построен таким же образом, только итерация по строчкам а операции сложения выполняются с целыми строками.

Для растяжения изображений с малым коэффициентом менее 1 подходит билинейная интерполяция.
Для коэффициентов больше единицы лучше использовать двумерную интерполяцию Лагранжа с матрицей коэффициентов 4x4 или двумерный B-сплайн. При расчете промежуточных точек используется метод наложения цифровых фильтров. 

## Цифровые фильтры

Цифровые фильтры применяются для выделения границ изображений и для сглаживания изображения. 
Фильтры задаются матрицей 2x2 3x3 4x4 .. NxN.
```c
c = 0;
for (int k=0; k<N; k++){
    for (int i=0; i<N; i++){
        с += F[i+N*k]*Img[width*k+i+offset];
    }
}
```
Для каждой точки изображения рассчитывается сумма с весовыми коэффициентами
$$с_{y,x} =\sum_{k=0}^{N-1}\sum_{i=0}^{N-1} F_{k,i} X_{j+y,i+x}$$

Коэффициенты фильтров могут быть подобраны таким образом, чтобы совмещать субпиксельную обработку и фильтрацию. Для субпиксельной обработки можно использовать коэффициенты рассчитанные с использованием интерполяции Лагранжа или B-сплайнов. 

## Распознавание движения

Распознавание делается из сравнения куда смещаются блоки изображения между двумя кадрами. Задача - как каждому блоку сопоставить вектор смещения. Матрицу векторов можно построить с использованием корреляционной функции. 

## Выделение контура изображения

Контур - замкнутый. Контур задается по точкам, а направление обхода контура задает отношение - внутренний или внешний контур. Вся векторная графика строится на контурах, `path` - путь, который может быть не замкнут и содержать несколько контуров. Контур может содержать признак типа для каждой точки. Точка может быть узловая, а сегмент к которому она относится - может быть линейным, квадратичным или кубическим сплайном. Так например, фигуры типа контур шрифта описывается квадратичными сплайнами. Для описания одного символа может потребоваться несколько контуров: внешние и внутренние.

Для выделения контура может быть удобно применить пороговую функцию по яркости или цвету пикселей. 

Над контурами можно выполнять ряд операций - выполнять заливку контура цветом, рисовать контур линией заданной толщины. Контур можно по точкам преобразовать в заданные координаты с использованием аффинного преобразования. 

Функция сравнения контуров должна вернуть достоверность [0,1] и ориентацию контура относительно точки отсчета - геометрического центра изображения. 

Кроме того нужна функция определения принадлежит ли данная точка контуру, находится внутри или на границе, на каком расстоянии от контура.

Действие со сплайнами - деление сплайна пополам - разбиение сплайнов.

## Заливка контура

Для заливки контура используется та же техника субпиксельной обработки, как при масштабировании изображений. Контур разбивается на прямоугольные фрагменты и трапеции по строкам конечного изображения. Таким образом следует рассмотреть алгоритм рисования линейной границы изображения с субпиксельной обработкой прозрачности границы изображения. Прозрачность позволяет реализовать полутоновый переход при заливке цветом. Фактически мы делаем из контура слой изображения, который содержит только альфа-канал (прозрачность). 

Допустим слева все прозрачно, а справа - нет, нам нужно изобразить границу. Каждый пиксель на границе имеет свою прозрачность пропорционально площади перекрытия квадратного пикселя и трапеции.  

Алгоритм можно записать в целых числах:
```c
do {
    ex += A;
    if (ex >= B) {
        ex -= B;
        Im[x,y] += (A-ex);
        y = y+1;
        Im[x,y] = ex;
    } else
        Im[x] = A;
    x = x+1;
} while (x < W);
```

## Наложение изображений с Альфа-каналом

В общем случае наложение выполняется с использованием alfa - канала. Это еще одна компонента цвета пикселя - прозрачность. С учетом прозрачности пикселя операция наложения будет выглядеть так:
```cpp
    pixel(x,y).color = pixel(x,y).color*(1-alpha) + Img2[x,y]*alpha;
```
Если фоновое (финальное) изображение содержит альфа-канал цветности, то операция наложения должна выполняться с учетом альфа канала входного и выходного изображения.

Обозначим $\{C,\alpha\}_{bg}$ - цвет и прозрачность фона (background), $\{C,\alpha\}_{fg}$ - цвет и прозрачность накладываемого изображения (foreground). Прозрачность выражаем в дробных числах $[0,1]$, где за единицу принимаем не прозрачное изображение.
```math
\alpha_{mix} = 1 \cdot \alpha_{fg} + \alpha_{bg}(1-\alpha_{fg})
```
```math
\alpha_{mix} \cdot C_{mix} = C_{fg} \cdot \alpha_{fg} + C_{bg}\cdot \alpha_{bg}(1-\alpha_{fg})
```
Операция может быть выполнена на сплайнах. Перепишем с использованием операции `mix(a,b, t) = a*(1-t) + b*t`:
```cpp
alpha_mix = mix(alpha_bg, 1, alpha_fg);
color_mix = mix(color_bg * alpha_bg, color_fg, alpha_fg)/alpha_mix;
```
В схеме RBGA каждая компонента цвета R,G,B рассчитывается независимо по формуле цвета. 

## Цветовые схемы

Обработка изображений выполняется в вещественных числах `float32`, `float16` или в числах с фиксированной точкой. Для рендеринга используются варианты упаковки формата RGBA и YCbCr, аппаратно поддерживаемые на данной платформе. Поддержка форматов определяется графической библиотекой и драйвером. Мы привязываемся к спецификациям [OpenCL](https://www.khronos.org/opencl) и [OpenVG](https://www.khronos.org/openvg), которые являются основой стандартизации графических драйверов для GPU.

[sRGB](#sRGB) - стандартное представление RGB

Схема кодирования YPbPr описывается формулой:

```math
\begin{aligned}
Y    &=K_{R}\cdot R+(1-K_{R}-K_{B})\cdot G+K_{B}\cdot B\\
P_{B}&={\frac {1}{2}}\cdot {\frac {B-Y}{1-K_{B}}}\\
P_{R}&={\frac {1}{2}}\cdot {\frac {R-Y}{1-K_{R}}}
\end{aligned}
```
где коэффициенты $K_B, K_R$ выбираются по стандарту ITU-R BT.601. А компоненты цвета могут подвергаться гамма-коррекции. 

Стандартные значения ITU-R BT.601:
$K_{R}=0.299$, $K_{G}=0.587$, $K_{B}=0.114$.

Стандартные значения ITU-R BT.709:
$K_{R}=0.2126$, $K_{G}=0.7152$, $K_{B}=0.0722$.

Стандартные значения ITU-R BT.2020:
$K_{R}=0.2627$, $K_{G}=0.6780$, $K_{B}=0.0593$.


Схемы YСС используются при кодировании видео и изображений со сжатием, например в JPEG. При вычислении компонент цвета используются дискретные (целые числа) и аналоговые величины (вещественные числа). В вещественных числах схема называется YPbPr, в целых YCbCr 

Преобразование в схему YPbPr из аналогового представления RGB:
```math
\begin{aligned}
Y     &=&    0.299\cdot R &+&    0.587\cdot G &+&    0.114\cdot B\\
P_{B} &=&-0.168736\cdot R &-& 0.331264\cdot G &+&      0.5\cdot B\\
P_{R} &=&      0.5\cdot R &-& 0.418688\cdot G &-& 0.081312\cdot B
\end{aligned}
```
В схеме YPbPr компоненты цвета определяют яркость (luma) и насыщенность (chroma) и заданы действительными числами на интервале $[0,1]$.

В схеме YCbCr используются целые числа определенной разрядности, например [8:4:4]. 

> Теорию цветового зрения RGB впервые высказал в 1756 году М. В. Ломоносов, когда он писал «о трёх материях дна ока». Сто лет спустя её развил немецкий учёный Г. Гельмгольц.
>
> Параллельно существовала [оппонентная теория цвета](https://en.wikipedia.org/wiki/Opponent_process) Гёте (1810), и Эвальда Геринга (1892). Её развили Дэвид Хьюбел и Торстен Визел.
> Они предположили, что в мозг поступает информация вовсе не о красном (R), зелёном (G) и синем (B) цветах. Мозг получает информацию о разнице яркости — о разнице яркости белого (Yмах) и чёрного (Yмин), о разнице зелёного и красного цветов (G — R), о разнице синего и жёлтого цветов (B — yellow), а жёлтый цвет (yellow = R + G) есть сумма красного и зелёного цветов.

[LMS](https://en.wikipedia.org/wiki/LMS_color_space) — цветовое пространство, представляющее собой отклики трёх типов фоторецепторов (колбочек) человеческого зрения. Можно построить цветовую схему и матрицу преобразования и для такой схемы.

Говорят о ночном и дневном зрении, за которое отвечают два разных типа фоторецепторов. Ночное зрение - черно-белое. Таким образом, можно говорить про трехкомпонентную схему кодирования цвета, которая будет меняться в зависимости от уровня освещенности. Современное представление говорит о четырех компонентах (красный, зеленый, фиолетовый и яркость белого) и адаптивных эффектах между оппонентными цветами. По этой причине кодирование оппонентными цветами кажется более приближенным к человеческому восприятию. 

Для строгой привязки разных цветовых схем и построения матриц преобразования, цветовые схемы приводятся к [хроматической схеме CIE XYZ](https://en.wikipedia.org/wiki/Color_model)

## Гамма-коррекция 

Изначально гамма-коррекция понятие введенное для коррекции яркости изображения, для компенсации искажений цвета монитором (телевизором). 
Гамма - коррекция может быть задана степенной функцией.

Современное требование - представление стандартных цветов sRGB с учетом "гамма-коррекции".
Стандарт [OpenCL C](https://registry.khronos.org/OpenCL/specs/3.0-unified/pdf/OpenCL_C.pdf) так описывает преобразование из sRGB (8 бит целые числа) в RGB с вещественными компонентами цвета:
```c
if (c <= 0.04045),
  result = c / 12.92;
else
  result = powr((c + 0.055) / 1.055, 2.4);
```
Обратное преобразование из линейного RGB вещественных числах в 8-бит sRGB с округлением к ближайшему целому, сочетает в себе функцию clamp(x, 0, 1.0).
```c
if (c > 1.0)
  c = 1.0;
else if (c < 0.0)
  c = 0.0;
else if (c < 0.0031308)
  c = 12.92 * c;
else
  c = 1.055 * powr(c, 1.0/2.4) - 0.055;
scaled_reference_result = c * 255
channel_component = floor(scaled_reference_result + 0.5);
```
При переводе формата из вещественных чисел в целые возникает потеря точности. Чтобы компенсировать потерю точности остаток может добавляться к яркости соседних пикселей. 