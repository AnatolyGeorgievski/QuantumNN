/*!
    Implementation of modular arithmetic and polynomial operations for Ring-LWE based cryptographic schemes.
    Optimized for x86-64 with AVX512 instructions, focusing on the prime modulus q = 2^23 - 2^13 + 1 = 8380417.
    The code supports operations in the polynomial ring R_q = Z_q[x]/(x^256 + 1).

    –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –º–æ–¥—É–ª–µ–π $q = 2^{32} - A‚ãÖ2^{16} - 1$, –º–æ–¥—É–ª–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö MWC32 (Multiply-with-carry)

    –°–±–æ—Ä–∫–∞
$ gcc -march=native -O3 -o test qnn_hexl.c

–í—Å–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç –≤–µ–∫—Ç–æ—Ä–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ 64–±–∏—Ç. –≠—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —Ç–µ–º —á—Ç–æ –ø—Ä–∏ —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–∏ —á–∏—Å–µ–ª 32 –±–∏—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è 64 –±–∏—Ç–Ω–∞—è –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞. 

–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
–ù–∞ x86 –µ—Å—Ç—å –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —É–º–Ω–æ–∂–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤ 32—Ö32=64 –±–∏—Ç–∞. –ù–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ mullo –∏ mulhi –¥–ª—è epu32, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –≤ 32 –±–∏—Ç–∞—Ö.
–ï—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å 52 –±–∏—Ç–Ω—ã–º–∏ —Ü–µ–ª—ã–º–∏ —á–∏—Å–ª–∞–º–∏, –Ω–æ –æ–ø–µ—Ä–∞–Ω–¥—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º –Ω–∞ 64 –±–∏—Ç.

–ü—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –æ–ø–µ—Ä–∞—Ü–∏–∏:
1. –°–ª–æ–∂–µ–Ω–∏–µ –º–æ–¥—É–ª—å–Ω–æ–µ
2. –í—ã—á–∏—Ç–∞–Ω–∏–µ –º–æ–¥—É–ª—å–Ω–æ–µ
3. –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É 32 –±–∏—Ç–∞.
4. –ü–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤ –ø–æ –º–æ–¥—É–ª—é. 

__m512i _mm512_cvtepu32_epi64 (__m256i a) -- –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ 32—Ö8 –≤ 64—Ö8

References:
* [[2306.01989](https://arxiv.org/pdf/2306.01989)] Optimized Vectorization Implementation of CRYSTALS-Dilithium
* [[2103.16400](https://arxiv.org/pdf/2103.16400)] Intel HEXL: Accelerating Homomorphic Encryption with Intel AVX512-IFMA52
* [[2018/039](https://eprint.iacr.org/2018/039.pdf)] Faster AVX2 optimized NTT multiplication for Ring-LWE lattice cryptography

* [[NIST:fips.203](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.203.pdf)] Module-Lattice-Based Key-Encapsulation Mechanism Standard. Tech. rep. National Institute of Standards and Technologies, 2024.\
(http://dx.doi.org/10.6028/NIST.FIPS.203)
* [[NIST:fips.204](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.204.pdf)] Module-Lattice-Based Digital Signature Standard. Tech. rep. National Institute of Standards and Technologies, 2024.\
(http://dx.doi.org/10.6028/NIST.FIPS.204)

–†–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é:
y = x - ‚åäx/q‚åã*q - –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è x –Ω–∞ q
‚åäx/q‚åã = –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –æ–±—Ä–∞—Ç–Ω–æ–µ —á–∏—Å–ª–æ, Ur = ‚åä2^L/q‚åã
‚åäx/q‚åã = ((x>>32)*Ur)>>(32+n) - —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –æ–±—Ä–∞—Ç–Ω–æ–µ —á–∏—Å–ª–æ –ø–æ –º–æ–¥—É–ª—é q
-- —ç—Ç–æ –Ω–µ –ø–æ–ª–Ω–æ–µ —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ, —Ç—Ä–µ–±—É–µ—Ç—Å—è –µ—â—ë –æ–¥–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞: 
min(y-q, y) = (y-q)<y? y-q: y;

–ß—Ç–æ–±—ã —É–ª–æ–∂–∏—Ç—å—Å—è –≤ 64 –±–∏—Ç–∞ –ø—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ Ur –¥–ª—è 32 –±–∏—Ç–Ω—ã—Ö prime, 
–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è, –∫–∞–∫ ‚åä(2^{64}-q)/q‚åã.

–°—Ç–∞–Ω–¥–∞—Ä—Ç—ã NIST —Å–µ—Ä–∏–∏ PQC –ø—Ä–∏–º–µ–Ω—è—é—Ç Ring-LWE –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —Å—Ö–µ–º—ã —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∏ –∏ 
—Å—Ö–µ–º—ã –≤—ã—Ä–∞–±–æ—Ç–∫–∏ –∫–ª—é—á–µ–π –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏. 
–ò—Å–ø–æ–ª—å–∑—É—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:
* The prime number $ùëû = 2^{23} ‚àí 2^{13} + 1 = 8380417$
* –∫–æ–ª—å—Ü–æ –ø–æ–ª–∏–Ω–æ–º–æ–≤ $\mathcal{R}_q = \mathbb{Z}_q[x]/(x^{256} + 1)$

*/

#include <x86intrin.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>


// Prime modulus q = 2^23 - 2^13 + 1
// #define Q_PRIME 8380417
// Prime modulus q = A0*2^16 - 1
#define Q_PRIME (((0xFFA0u)<<16)-1)
// Barrett constant u = ‚åä(2^64 - q)/q‚åã
#define U_BARRETT ((uint32_t)(((uint64_t)(-Q_PRIME) << 32) / Q_PRIME))

#ifdef __AVX512F__
typedef uint32_t uint32x16_t __attribute__((__vector_size__(64)));
// –º–æ–¥—É–ª—å q
static inline __m512i _mod1(__m512i x, __m512i q){
    return _mm512_min_epu32(x, _mm512_sub_epi32(x, q));
}

static inline __m512i _addm(__m512i a, __m512i b, __m512i q){
    __m512i d = _mm512_add_epi32(a, b);
    __m512i t = _mm512_sub_epi32(d, q);
    return _mm512_min_epu32(d, t);
//    return _mod1(_mm512_add_epi32(a, b), q);
}
static inline __m512i _subm(__m512i a, __m512i b, __m512i q){
    __m512i d = _mm512_sub_epi32(a, b);
    __m512i t = _mm512_add_epi32(d, q);
    return _mm512_min_epu32(d, t);
}
static inline __m512i _mulhi(__m512i a, __m512i b, __m512i q){
    __m512i d0 = _mm512_mul_epu32(a, b);
    __m512i d1 = _mm512_mul_epu32(_mm512_srli_epi64 (a, 32), _mm512_srli_epi64 (b, 32));
    return _mm512_mask_mov_epi32(_mm512_srli_epi64(d0, 32), (__mmask16)0xAAAA, d1);
}
/*! \brief Barrett reduction
    \param d - vector 64 bits x8
    \param q - modulus $2^{31} < q < 2^{32}$
    \param u - barrett constant \lfloor (2^{64}-q)/q \rfloor 
    \return $d \mod q$

–í –Ω–∞—à–µ–π –≤–µ—Ä—Å–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∏–Ω—ã–µ —Å–¥–≤–∏–≥–∏ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–µ –Ω–∞ 32 –±–∏—Ç–∞, –∏–Ω–∞—á–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –æ–±—Ä–∞—Ç–Ω–æ–π –≤–µ–ª–∏—á–∏–Ω—ã (–∫), —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é mulhi.
$u = \lfloor (2^{64}-q)/q \rfloor$ –ø–æ–¥–æ–±—Ä–∞–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ —Ç–∞–∫–æ–º –≤–∏–¥–µ. 

1. function Partial_Reduction(ùëë, ùëû, u, ùëÑ=32, ùêø=64)
2.   ùëê_1 ‚Üê ùëë ‚â´ Q
3.   ùëê_2 ‚Üê d + ùëò‚ãÖùëê_1
4.   ùëê_3 ‚Üê ùëê_2 ‚â´ (L-Q)
5.   ùëê_4 ‚Üê ùëë ‚àí ùëû‚ãÖùëê_3
6.   if ùëê_4 ‚â• q then
7.      ùëê_4 ‚Üê ùëê_4 ‚àí ùëû
8.   end if
9.   return $ùëê_4$
10.end function

 */
static inline __m512i _barret(__m512i d, __m512i q, __m512i u){
    __m512i c1, c2, c3, c4;
    c1 = _mm512_srli_epi64(d, 32);
    c2 = _mm512_add_epi64 (d, _mm512_mul_epu32(c1, u));
    c3 = _mm512_srli_epi64(c2, 32);
    c4 = _mm512_sub_epi64 (d, _mm512_mul_epu32(c3, q));
    return _mm512_min_epu64(c4, _mm512_sub_epi64(c4, q));
}
#define Q 32

/*! \brief Multiplication modulo q 

–í–µ–∫—Ç–æ—Ä uint32x16_t
    \param a - first operand
    \param b - second operand
    \param q - modulus $2^{31} < q < 2^{32}$
    \param u - barrett constant \lfloor (2^{64}-q)/q \rfloor
    \return $a \cdot b \mod q$
 */
static inline __m512i _mulm(__m512i a, __m512i b, __m512i q, __m512i u){
    __m512i d0 = _mm512_mul_epu32(a, b);
    __m512i d1 = _mm512_mul_epu32(_mm512_srli_epi64(a,32), _mm512_srli_epi64(b,32));
    d0 =  _barret(d0, q, u);
    d1 =  _barret(d1, q, u);
    return _mm512_unpacklo_epi32(d0, d1);
}
static inline __m512i _macm(__m512i a, __m512i b, __m512i c, __m512i q, __m512i u){
    //a = _mm512_madd52lo_epu64(a, b, c);// a+ b*c
    a = _mm512_add_epi64(a, _mm512_mul_epu32(b,c));
    return _barret(a, q, u);
}
/*! \brief Square modulo q 
    \param a - first operand
    \param q - modulus $2^{31} < q < 2^{32}$
    \param u - barrett constant \lfloor (2^{64}-q)/q \rfloor 
    \return $a^2 \mod q$
 */
static inline __m512i _sqrm(__m512i a, __m512i q, __m512i u){
    __mm512i b = _mm512_srli_epi64(a, 32);
    a = _mm512_mul_epu32(a, a);
    b = _mm512_mul_epu32(b, b);
    a = _barret(a, q, u);
    b = _barret(b, q, u);
    return _mm512_unpacklo_epi32(a, b);
}

/*! \brief Element-wise polynomial multiplication modulo q.
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).
    \param result Output polynomial (array of 256 uint32_t coefficients).

    \note Processes 16 coefficients at a time using AVX512, for polynomials in R_q = Z_q[x]/(x^{256} + 1).
 */
void poly_mulm(const uint32_t *a, const uint32_t *b, uint32_t *result) {
    __m512i q = _mm512_set1_epi32(Q_PRIME);
    __m512i u = _mm512_set1_epi64(U_BARRETT);
    for (int i = 0; i < 256; i += 16) {
        __m512i va = _mm512_loadu_epi32((const void *)(a + i));
        __m512i vb = _mm512_loadu_epi32((const void *)(b + i));
        __m512i vr = _mulm(va, vb, q, u);// –∞–ª–≥–æ—Ä–∏—Ç–º —É–º–Ω–æ–∂–µ–Ω–∏—è –ø–æ –º–æ–¥—É–ª—é —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —á–∏—Å–ª–∞–º–∏ 64 –±–∏—Ç–∞.
        _mm512_storeu_epi32(result + i, vr);
    }
}
static inline void poly_mulm_u(const uint32_t *a, const uint32_t b, uint32_t *result) {
    __m512i q = _mm512_set1_epi32(Q_PRIME);
    __m512i u = _mm512_set1_epi64(U_BARRETT);
    __m512i vb = _mm512_set1_epi32(b);
    for (int i = 0; i < 256; i += 16) {
        __m512i va = _mm512_loadu_epi32((const void *)(a + i));
        __m512i vr = _mulm(va, vb, q, u);// –∞–ª–≥–æ—Ä–∏—Ç–º —É–º–Ω–æ–∂–µ–Ω–∏—è –ø–æ –º–æ–¥—É–ª—é —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —á–∏—Å–ª–∞–º–∏ 64 –±–∏—Ç–∞.
        _mm512_storeu_epi32(result + i, vr);
    }
}
/*! \brief Element-wise polynomial addition modulo q.
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).
    \param result Output polynomial (array of 256 uint32_t coefficients).
    
    \note Processes 16 coefficients at a time using AVX512, for polynomials in R_q = Z_q[x]/(x^{256} + 1).
 */
static inline void poly_addm(const uint32_t *a, const uint32_t *b, uint32_t *result) {
    __m512i q = _mm512_set1_epi32(Q_PRIME);
    for (int i = 0; i < 256; i += 16) {
        __m512i va = _mm512_loadu_epi32((const void *)(a + i));
        __m512i vb = _mm512_loadu_epi32((const void *)(b + i));
        __m512i vr = _addm(va, vb, q);
        _mm512_storeu_epi32(result + i, vr);
    }
}
/*! \brief —Å–¥–≤–∏–≥ –∏ —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ (b) –ø–æ –º–æ–¥—É–ª—é (x^N + 1) –∏ —Å–ª–æ–∂–µ–Ω–∏–µ —Å –ø–æ–ª–∏–Ω–æ–º (a)
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).
    \param r Output polynomial (array of 256 uint32_t coefficients).
 */
static inline void poly_xtime_addm(const uint32_t *a, const uint32_t *b, uint32_t *r) {
    __m512i q = _mm512_set1_epi32(Q_PRIME);
    __m512i c = _mm512_loadu_epi32((const void *)(b + 256-16)); // –ø–µ—Ä–µ–Ω–æ—Å
    c = _mm512_sub_epi32(q, c);         // c = q - c
    for (int i = 0; i < 256; i += 16) {
        __m512i va = _mm512_loadu_epi32((const void *)(a + i));
        __m512i vb = _mm512_loadu_epi32((const void *)(b + i));
        c = _mm512_alignr_epi32 (vb,c, 15);
        va = _addm(va, c, q);
        _mm512_storeu_epi32(r + i, va);
        c = vb;
    }
}
/*! \brief –û–ø–µ—Ä–∞—Ü–∏—è —É–º–Ω–æ–∂–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ –Ω–∞ —Å–∫–∞–ª—è—Ä –∏ —Å–ª–æ–∂–µ–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º r = r*x + a*\beta
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b scalar (uint32_t).
    \param r Output polynomial (array of 256 uint32_t coefficients).
 */
static inline void poly_xtime_madd(const uint32_t *a, const uint32_t b, uint32_t *r) {
    __m512i q = _mm512_set1_epi32(Q_PRIME);
    __m512i u = _mm512_set1_epi64(U_BARRETT);
    __m512i vb= _mm512_set1_epi32(b);
    __m512i c = _mm512_loadu_epi32((const void *)(r + 256-16)); // –ø–µ—Ä–µ–Ω–æ—Å
    c = _mm512_sub_epi32(q, c);
    for (int i = 0; i < 256; i += 16) {
        __m512i va = _mm512_loadu_epi32((const void *)(a + i)); 
        __m512i vr = _mm512_loadu_epi32((const void *)(r + i));
        va = _mulm(va, vb, q, u);
        c  = _mm512_alignr_epi32 (vr,c, 15);
        va = _addm(va, c, q);
        _mm512_storeu_epi32(r + i, va);
        c = vr;
    }
}
#elif defined(__AVX2__)
typedef uint32_t uint32x8_t __attribute__((__vector_size__(32)));
static inline __m256i _mod1_avx2(__m256i x, __m256i q){
    return _mm256_min_epu32(x, _mm256_sub_epi32(x, q));
}
static inline __m256i _barret_avx2(__m256i d, __m256i q, __m256i u) {
    __m256i c1 = _mm256_srli_epi64(d, 32);
    __m256i c2 = _mm256_add_epi64(d, _mm256_mul_epu32(c1, u));
    __m256i c3 = _mm256_srli_epi64(c2, 32);
    __m256i c4 = _mm256_sub_epi64(d, _mm256_mul_epu32(c3, q));
    __m256i c4_minus_q = _mm256_sub_epi64(c4, q);       // Compare c4 < c4_minus_q (unsigned comparison)
    __m256i cmp = _mm256_cmpgt_epi64(c4_minus_q, c4);   // c4_minus_q > c4
    return _mm256_blendv_epi8(c4_minus_q, c4, cmp);     // Select: if c4 < c4_minus_q, take c4; else take c4_minus_q
}
static inline __m256i _addm_avx2(__m256i a, __m256i b, __m256i q) {
    __m256i d = _mm256_add_epi32(a, b);
    __m256i t = _mm256_sub_epi32(d, q);
    return _mm256_min_epu32(d, t);
}
static inline __m256i _subm_avx2(__m256i a, __m256i b, __m256i q) {
    __m256i d = _mm256_sub_epi32(a, b);
    __m256i t = _mm256_add_epi32(d, q);
    return _mm256_min_epu32(d, t);
}
static inline __m256i _mulm_avx2(__m256i a, __m256i b, __m256i q, __m256i u){
    __m256i d0 = _mm256_mul_epu32(a, b);
    __m256i d1 = _mm256_mul_epu32(_mm256_srli_epi64(a, 32), _mm256_srli_epi64(b,32));
    d0 = _barret_avx2(d0, q, u);
    d1 = _barret_avx2(d1, q, u);
    return _mm256_unpacklo_epi32(d0, d1);
}
/*! \brief Element-wise polynomial multiplication modulo q.
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).    
    \param result Output polynomial (array of 256 uint32_t coefficients).
    
    \note Processes 8 coefficients at a time using AVX2, for polynomials in R_q = Z_q[x]/(x^{256} + 1).
 */
static inline void poly_mulm(const uint32_t *a, const uint32_t *b, uint32_t *result) {
    __m256i q = _mm256_set1_epi32(Q_PRIME);
    __m256i u = _mm256_set1_epi64x(U_BARRETT);
    for (int i = 0; i < 256; i += 8) {
        __m256i va = _mm256_loadu_si256((__m256i *)(a + i));
        __m256i vb = _mm256_loadu_si256((__m256i *)(b + i));
        __m256i vr = _mulm_avx2(va, vb, q, u);
        _mm256_storeu_si256((__m256i *)(result + i), vr);
    }
}
/*! —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ (b) –∏ —Å–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–æ–≤ x^N + 1
N = 256 
 */
static inline void poly_xtime_addm(const uint32_t *a, const uint32_t *b, uint32_t *r, unsigned int N) {
    __m256i q = _mm256_set1_epi32(Q_PRIME);
    __m256i c = _mm256_loadu_si256((__m256i *)(b + 256-8)); // –ø–µ—Ä–µ–Ω–æ—Å
    c = _mm256_sub_epi32(q, c);         // c = q - c
    for (int i = 0; i < 256; i += 8) {
        __m256i va = _mm256_loadu_si256((__m256i *)(a + i));
        __m256i vb = _mm256_loadu_si256((__m256i *)(b + i));
        c = _mm256_alignr_epi32 (vb,c, 7);
        va = _addm_avx2(va, c, q);
        _mm256_storeu_si256((__m256i *)(r + i), va);
        c = vb;
    }
}

/*! \brief –û–ø–µ—Ä–∞—Ü–∏—è —É–º–Ω–æ–∂–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ –Ω–∞ —Å–∫–∞–ª—è—Ä –∏ —Å–ª–æ–∂–µ–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º r = r*x + a*\beta
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b scalar (uint32_t).
    \param r Output polynomial (array of 256 uint32_t coefficients).
    \param N —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞
 */
static inline 
void poly_xtime_madd(const uint32_t *a, const uint32_t b, uint32_t *r, unsigned int N) {
    __m256i q = _mm256_set1_epi32 (Q_PRIME);
    __m256i u = _mm256_set1_epi64x(U_BARRETT);
    __m256i vb= _mm256_set1_epi32 (b);
    __m256i c = _mm256_loadu_si256((__m256i *)(r + 256-8)); // –ø–µ—Ä–µ–Ω–æ—Å
    for (int i = 0; i < N; i += 8) {
        __m256i va = _mm256_loadu_si256((__m256i *)(a + i));
        __m256i vr = _mm256_loadu_si256((__m256i *)(r + i));
        va = _mulm_avx2(va, vb, q, u);
        c  = _mm256_alignr_epi32 (vr,c, 7);// —É—Ç–æ—á–Ω–∏—Ç—å
        va = _addm_avx2(va, c, q);
        _mm256_storeu_si256((__m256i *)(r + i), va);
        c = vr;
    }
}
/*! \brief Element-wise polynomial addition modulo q.
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).    
    \param result Output polynomial (array of 256 uint32_t coefficients).
    \param N —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞ (x^N + 1)
    
    \note Processes 8 coefficients at a time using AVX2, for polynomials in R_q = Z_q[x]/(x^{N} + 1).
 */
static inline 
void poly_addm(const uint32_t *a, const uint32_t *b, uint32_t *result, unsigned int N) {
    __m256i q = _mm256_set1_epi32(Q_PRIME);
    for (int i = 0; i < N; i += 8) {
        __m256i va = _mm256_loadu_si256((__m256i *)(a + i));
        __m256i vb = _mm256_loadu_si256((__m256i *)(b + i));
        __m256i vr = _addm_avx2(va, vb, q);
        _mm256_storeu_si256((__m256i *)(result + i), vr);
    }
}
/*! \brief Element-wise polynomial substraction modulo q.
    \param a First polynomial (array of 256 uint32_t coefficients).
    \param b Second polynomial (array of 256 uint32_t coefficients).    
    \param result Output polynomial (array of 256 uint32_t coefficients).
    \param N —Å—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∞ (x^N + 1)
 */
static inline void poly_subm(const uint32_t *a, const uint32_t *b, uint32_t *result, unsigned int N) {
    __m256i q = _mm256_set1_epi32(Q_PRIME);
    for (int i = 0; i < N; i += 8) {
        __m256i va = _mm256_loadu_si256((__m256i *)(a + i));
        __m256i vb = _mm256_loadu_si256((__m256i *)(b + i));
        __m256i vr = _subm_avx2(va, vb, q);
        _mm256_storeu_si256((__m256i *)(result + i), vr);
    }
}
#endif
/*! \brief –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –≤–∏–¥ –∏–Ω–≤–µ—Ä—Å–∏–∏ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏—è $\lfloor (2^{64}-q)/q \rfloor$ 
    Ur = 2^{32}+INVL(q);
 */
static inline uint32_t INVL(uint32_t v) {
    return ((unsigned __int64)(-v)<<32)/v;
}
static inline uint32_t MULM(uint32_t a, uint32_t b, uint32_t q) {
    return ((unsigned __int64)a*b)%q;
}
static inline uint32_t SQRM(uint32_t a, uint32_t q) {
    return ((unsigned __int64)a*a)%q;
}
static inline uint32_t MOD(uint64_t a, uint32_t q) {
    return a%q;
}
static inline uint32_t SLM(uint32_t a, uint32_t q) {
    return ((unsigned __int64)a<<1)%q;
}
static inline uint32_t SRM(uint32_t a, uint32_t q) {
    return (a&1)? (a+(unsigned __int64)q)>>1: (a>>1);
}
/*! –†–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞, —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ë–∞—Ä—Ä–µ—Ç—Ç–∞ */
static inline uint32_t MODB(uint64_t a, uint32_t q, uint32_t U) {
    uint64_t c2 = a + U*(a >>32);
    uint64_t c4 = a - q*(c2>>32);
    return  (c4>= q)? c4 - q: c4;
}
/*! \brief –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö 
    \param h - —Ö–µ—à-–∫–æ–¥ 0 <= h < q
    \param d - –¥–∞–Ω–Ω—ã–µ 
    \param q - –º–æ–¥—É–ª—å –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞
    \param U - —Å–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –ë–∞—Ä—Ä–µ—Ç—Ç–∞ U = ‚åä(2^{64} ‚àíq)/q‚åã 
    \param K - —Å–¥–≤–∏–≥–æ–≤–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞, K = 2^N mod q
    \return —Ö–µ—à-–∫–æ–¥ 32 –±–∏—Ç–∞
 */
static inline uint32_t FOLD(uint32_t h, uint32_t d, uint32_t q, uint32_t U, uint32_t K) {
    uint64_t c1 = d  + ((uint64_t)K*h); 
#if 0// Ur = ‚åä2^{64}/q‚åã 
    uint64_t c2 = U*(c1>>31) + (c1>>31<<32);
    uint64_t c4 = c1 - q*(c2>>33);// (a<<16)+(c2>>33)
#else
    uint64_t c2 = c1 + U*(c1>>32);// {c1.l, 0} + {U, 1} * {c1.h, 0}-> {mad(), c1.h + mad_hi()}
    uint64_t c4 = c1 - q*(c2>>32);// {c1.l, c1.h} - {q, 0} * {c2.h, 0}-> {mad(), c1.h + mad_hi()}
#endif
    return  (c4-q< c4)? c4 - q: c4;
//    return  (c4>= q)? c4 - q: c4;
}
static inline uint32_t FOLD_(uint32_t h, uint32_t d, uint32_t q, uint32_t U, uint32_t K) {
    uint64_t c1 = d  + ((uint64_t)h<<32); 
    return  c1%q;
}
/*! –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å –ø–æ –º–æ–¥—É–ª—é $m\cdot 2^a (\mod q)$
 */
static uint32_t ldexpm(const uint32_t m, uint32_t a, uint32_t q)
{
	uint32_t r = 2;
	uint32_t s = m;
    while (a!=0) {
		if (a&1) 
			s = ((uint64_t)s*r)%q;
		r = ((uint64_t)r*r)%q;// –ø–æ —Ç–∞–±–ª–∏—Ü–µ 
		a>>=1;
	}
	return s;
}
#include <math.h>
float convert_lwe_to_f32(uint32_t m, int ex, const uint32_t *Kr, uint32_t q){
    m = (m*(uint64_t)Kr[ex+148])%q; // —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ —Å–¥–≤–∏–≥–æ–≤—É—é –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –ø–æ –º–æ–¥—É–ª—é `q`
    int i = (m>>31)?(int)m-q:m; // –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞–∫
    return ldexpf(i, ex-24);
}
uint32_t convert_f32_to_lwe(float f, int *ex, const uint32_t *K, uint32_t q){
    f = frexpf(f,ex);     // –∑–∞–≥—Ä—É–∑–∫–∞ —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç—ã, —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [0.5,1)
    int32_t i = (f*(1u<<24));// –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –±–ª–∏–∂–∞–π—à–µ–≥–æ —Ü–µ–ª–æ–≥–æ RNE
    //if (i<0) i = q+i;
    uint32_t m = (i<0)?q+i:i;
    m = (m*(uint64_t)K[*ex+148])%q;
    return m;
}
uint32_t convert_f32_to_lwe_(float f, const uint32_t *K, const uint32_t *Kr, uint32_t q){
    const uint32_t M = (1u<<24);
    union {
        float f;
        uint32_t u;
    } v = {.f = f};
    
    int ex;
    f = frexpf(f,&ex);     // –∑–∞–≥—Ä—É–∑–∫–∞ —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç—ã, —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [0.5,1)
    int32_t i = (f*M);// –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –±–ª–∏–∂–∞–π—à–µ–≥–æ —Ü–µ–ª–æ–≥–æ RNE
    if (i<0) i = q+i;
    uint32_t m = i;
    m = (m*(uint64_t)K[ex+148])%q;
    //return m;
    //printf ("f=0x%08X m=%1.2f exp=%d: %08X\n", v.u, f, ex, m);
    if (v.f != convert_lwe_to_f32(m, ex, Kr, q))
        printf("fail %f != %f\n", f, convert_lwe_to_f32(m, ex, Kr, q));
/*    m = (m*(uint64_t)Kr[ex])%q;
    if (m>>31) i=i-q;// –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞–∫
    if (v.f != ldexpf(i, ex-24)) printf("fail %f != %f\n", f, ldexpf(i, ex));
    */
    return m;    // —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ —Å–¥–≤–∏–≥–æ–≤—É—é –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –ø–æ –º–æ–¥—É–ª—é `q`
}
static uint32_t POWM(const uint32_t b, uint32_t a, const uint32_t q)
{
	uint32_t r = b;
	uint32_t s = 1;
    while (a!=0) {
		if (a&1) 
			s = ((uint64_t)s*r)%q;
		r = ((uint64_t)r*r)%q;
		a>>=1;
	}
	return s;
}
/*! \brief –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –≤–∏–¥ –∏–Ω–≤–µ—Ä—Å–∏–∏ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏—è $\lfloor (2^{64}-q)/q \rfloor$ */
static inline uint64_t INVL128(uint64_t v) {
    return ((unsigned __int128)(-v)<<64)/v;
}
/*! –í–æ–∑–≤–æ–¥–∏—Ç –≤ —Å—Ç–µ–ø–µ–Ω—å –ø–æ –º–æ–¥—É–ª—é b^a mod P 
	–æ—á–µ–Ω—å –±—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç!
 */
typedef unsigned int __attribute__((mode(TI)))   uint128_t;
static uint64_t POWM128(const uint64_t b, uint64_t a, const uint64_t P)
{
	uint64_t r;
	r = b;
	uint64_t s = 1;
	int i;
    while (a!=0) {
		if (a&1) 
			s = ((uint128_t)s*r)%P;
		r = ((uint128_t)r*r)%P;
		a>>=1;
		//if (r==b) return 0;
	}
	return s;
}
/// Reference implementation
#define A0  0xFEA0u// 0xFF80u
#define Q0  ((A0<<16)-1)
/*! —Ñ—É–Ω–∫—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ FOLD(K=A), q=(A<<16)-1
 */
uint32_t mwc32_hash(uint32_t h, uint16_t d, uint32_t q, uint32_t a){
    h = (0xFFFF&h)*a + (h>>16) + d;// rotl(h, 16) - (0x10000 - a)*(uint16_t)h
    if (h>= q) h-=q;
    return h;
}

uint32_t mwc32_hash_16(uint32_t h, uint16_t d, uint32_t q, uint32_t a){
    h += d;
    h = (0xFFFF&h)*a + (h>>16);
//    if (h>= q) h-=q;
    return h;
}
/*! \brief –•—ç—à MWC32 –°–¥–≤–∏–≥ 2^{-16} - —Ä–µ–¥—É—Ü–∏—Ä–æ–≤–∞–Ω–∏–µ
    \param h - —Ö–µ—à-–∫–æ–¥ 32 –±–∏—Ç–∞
    \param d - –≤–µ–∫—Ç–æ—Ä 16 —Å —Ä–∞—Å–ø–∞–∫–æ–≤–∫–æ–π –Ω–∞ 32 –±–∏—Ç–∞ x16
    \param q - –º–æ–¥—É–ª—å $2^{31} < q < 2^{32}$, 
    \param a - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ $a < 2^{16}$
    \return $h*a + d \mod q$
 */

#if 1

/*! \brief –≤—ã—á–∏—Å–ª—è–µ–º –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –¥–ª—è –∑–∞–º–µ–Ω—ã A/B == ((A*C0)>>32 + A)>>(n-32)
 */
static uint32_t div_c0(uint32_t b, int *nd) 
{
	uint32_t C;
	int k = __builtin_ctz(b);// –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–æ–ª–∏–∫–æ–≤ –≤ –º–ª–∞–¥—à–µ–π —á–∞—Å—Ç–∏ —á–∏—Å–ª–∞
		// count trailing zeros
	b>>=k;
	if (b==1) {
		*nd = 32;
		C = 0;//0x1ULL<<32;
	} else
	{
		*nd = 64 - __builtin_clz(b);// –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–æ–ª–∏–∫–æ–≤ –≤ —Å—Ç–∞—Ä—à–µ–π —á–∞—Å—Ç–∏ —á–∏—Å–ª–∞
		C = (uint64_t)(((1ULL<<32)-b)<<(*nd-32))/b + (1ULL<<(*nd-32)) + 1;
	}
	*nd+=k;
	return C & 0xFFFFFFFFUL;
}/*! \brief –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –º–Ω–æ–∂–µ—Å—Ç–≤—É —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –±–µ–∑ –∑–Ω–∞–∫–∞ 32 –±–∏—Ç–∞ 
	–¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è uint32_t Q = (((A*(uint64_t)C0)>>32)+A)>>(n0-32);
 */
static int verify32(uint32_t B, uint32_t C0, int n0) {
	uint32_t A;
	for (A=(~0UL); A!=0; --A){// –≤—Å–µ —á–∏—Å–ª–∞ 32 –±–∏—Ç, –∫—Ä–æ–º–µ –Ω—É–ª—è
		uint32_t q = (((A*(uint64_t)C0)>>32)+A)>>(n0-32);
		if (q != (A/B)) {
			printf("fail A=0x%08X A/B=0x%08X Q=0x%08X \r\n", A, A/B, q);
			return 1;
		}
	}
	return 0;
}
// –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–µ—Ä–∏–æ–¥
uint32_t mwc32_period(uint32_t a){
	return (a<<15)-2;
}
/*! –ú–æ–¥—É–ª—å–Ω–æ–µ —É–ø–æ–ª–æ–≤–∏–Ω–∏–≤–∞–Ω–∏–µ */
static inline uint32_t hlvm(uint32_t v, uint32_t P){
	return (v&1)? ((uint64_t)v+P)>>1: (v>>1);
}
/*! –ü–æ—Ä—è–¥–æ–∫ –º—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω–æ–π –≥—Ä—É–ø–ø—ã –ø–æ –º–æ–¥—É–ª—é –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞ q=A*2^{16} -1 
 */
uint32_t mwc32_length(uint32_t gen, uint32_t P){
    uint32_t a = gen;
    uint32_t i;
    for ( i=0; i<P; ++i) {// –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–æ–¥—É–ª—å–Ω–æ–µ —É–ø–æ–ª–æ–≤–∏–Ω–∏–≤–∞–Ω–∏–µ –∏–ª–∏ —É–¥–≤–æ–µ–Ω–∏–µ
        a = hlvm(a, P);
        if (a == 1) break;
    }
    return i;
}
int main(int argc, char **argv){
    const uint32_t U0 = INVL(Q0);
#if __AVX512F__
    __m512i E = _mm512_set1_epi32(1);
    __m512i Z = _mm512_set1_epi32(0);
#endif
    uint64_t ur = (((uint128_t)1<<64))/Q0; // –ø—Ä–æ–≤–µ—Ä–∫–∞ (1<<32) + U0
    printf("Prime %08x, Ur %08x %08llx\n", Q0, U0, ur);
    if (1) {
        const uint32_t A1 = (0xFF80u);// –ø–µ—Ä–∏–æ–¥ –ø–æ–≤—Ç–æ—Ä–∞ 7fbffffe `-16`
        const uint32_t Q1 = (A1<<16)-1; 
        uint32_t K[256+24];
        uint32_t Kr[256+24];// –æ–±—Ä–∞—Ç–Ω—ã–µ —Å—Ç–µ–ø–µ–Ω–∏ 2^{-n}
        uint32_t hlv = POWM(2, mwc32_period(A1), Q1);
        for (int i=0; i<256+24; i++){// –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –∫–æ–Ω—Å—Ç–∞–Ω—Ç
            K[i] = POWM(2, i, Q1);
            Kr[i]= POWM(hlv, i, Q1);
        }
        if (0) for (int i=0; i<=255; i++){
            float f = i*(-781.33f);
            uint32_t w = convert_f32_to_lwe_(f, K, Kr, Q1);
        }
        for (uint32_t i=0; i<~0u; i++){
            int ex;
            float f = *(float*)&i;
            if (isnan(f)) continue;
            //if (!isnormal(f)) continue;
            uint32_t w = convert_f32_to_lwe(f, &ex, K, Q1);
            float g = convert_lwe_to_f32(w,ex, Kr, Q1);
            if (f != g){
                printf("fail cvt %g != %g ^%d\n", f, g, ex);
            }
        }
    }
    if (1) {
        uint32_t q0 = 8380417;
        int len = mwc32_length(1, q0);
        printf("Prime %08x, order %08x\n", q0, len);
        
        uint64_t ur = (((uint128_t)1<<64)-0)/q0;
        //uint64_t ur = INVL(q0);
        int nd = 64 - __builtin_clz(q0);// –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–æ–ª–∏–∫–æ–≤ –≤ —Å—Ç–∞—Ä—à–µ–π —á–∞—Å—Ç–∏ —á–∏—Å–ª–∞
        // uint64_t u0 = (uint64_t)(-q0)/q0;
        uint32_t u0 = div_c0(q0, &nd);
        int n0 = 32 - __builtin_clz(q0);
        
        printf("Prime %08x, Q = x%08x (%d bit) Ur=%08llx ", q0, u0, n0, ur);
        if (verify32(q0, u0, nd)) return 0;
        printf(" ..ok\n");
    }
    if (1) {
        uint32_t q0 = 8380417;
        int len = mwc32_length(1, q0);
        printf("Prime %08x, order %08x %s\n", q0, len, len==(q0/2-1)?"..ok":"");
        for (int i=0; i<=255; i++){
            uint32_t a = POWM(2, i, q0);
            // printf("%02x: %08x\n", i, a);
        }
    }
    if (1) {// –Ω–∞–π—Ç–∏ —Å–¥–≤–∏–≥–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        uint32_t A1 = (0xFF80u);// –ø–µ—Ä–∏–æ–¥ –ø–æ–≤—Ç–æ—Ä–∞ 7fbffffe `-16`
        uint32_t Q1 = (A1<<16)-1; 

    }
    const int n = 31;
    uint32_t a1 = 1;
    uint32_t a2 = 1;
    uint32_t h1 = 1, h2 = 1, h3 = 1;
    for (uint64_t i=1; i<=(uint64_t)Q0<<(32-n); i++){// –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—É—Ç–µ–º –ø–µ—Ä–µ–±–æ—Ä–∞ –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        if (0 && MODB(i<<n, Q0, U0) != MOD(i<<n, Q0)) {// –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ MODB
            printf("%llx: %08x != %08x\n", i, MODB(i<<n, Q0, U0), MOD(i<<n, Q0));
            break;
        }
#if __AVX512F__
        if (1) {// –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ–∫—Ç–æ—Ä–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
            __m512i U = _mm512_set1_epi64(U0);   // barrett constant
            __m512i q = _mm512_set1_epi64(Q0);   // prime

            uint64_t a = (i<<n)-1;
            __m512i x = _mm512_set1_epi64(a);
            __m512i y = _barret(x, q, U);
            __m128i z = _mm512_extracti64x2_epi64(y, 0);
            uint64_t v = _mm_extract_epi64(z, 0);
            uint64_t w = MOD(a, Q0);
            if (v != w) {
                printf("%llx: %08llx %08llx\n", i, v, w);
                break;
            }
        }
#elif __AVX2__
        if (1) {// –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ–∫—Ç–æ—Ä–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
            __m256i U = _mm256_set1_epi64x(U0);   // barrett constant
            __m256i q = _mm256_set1_epi64x(Q0);   // prime

            uint64_t a = (i<<n)-1;
            __m256i x = _mm256_set1_epi64x(a);
            __m256i y = _barret_avx2(x, q, U);
            __m128i z = _mm256_extracti128_si256(y, 0);
            uint64_t v = _mm_extract_epi64(z, 0);
            uint64_t w = MOD(a, Q0);
            if (v != w) {
                printf("%llx: %08llx %08llx\n", i, v, w);
                break;
            }
        }
#endif
        if (1) {// –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ FOLD
            uint64_t a = ~i;
            uint32_t f1 = FOLD(Q0-1, a, Q0, U0, -Q0);
            f1 = FOLD(f1, a, Q0, U0, -Q0);
            uint32_t f2 = FOLD_(Q0-1, a, Q0, U0, -Q0);
            f2 = FOLD_(f2, a, Q0, U0, -Q0);
            if (f1 != f2) {
                printf("fold %llx: %08x %08x\n", i, f1, f2);
                break;
            }
        }
        if (1) {
            uint32_t A1 = (0xFF80u);// –ø–µ—Ä–∏–æ–¥ –ø–æ–≤—Ç–æ—Ä–∞ 7fbffffe `-16`
            uint32_t Q1 = (A1<<16)-1; 
            a1 = SLM(a1, Q1);
            a2 = SRM(a2, Q1);
            if (a1 == 1) {
                printf("K_%llx: %08x\n", i, a1);
                //break;
            }
            if (a2 == A1) {
                printf("K_-%llx: %08x\n", i, a2);
                //break;
            }
        }
        h1 = mwc32_hash(h1, (uint16_t)i, Q0, A0);
        h3 = mwc32_hash_16(h3, (uint16_t)~i, Q0, A0);
        h2 = FOLD(h2, (uint16_t)i, Q0, U0, A0);
        if (h3 >= Q0) {
            printf("MWC_%llx: %08x >= q\n", i, h3);
            //break;
        }
        if (h1 != h2) {
            printf("MWC_%llx: %08x %08x\n", i, h1, h2);
            break;
        }
        
    }
    return 0;
}
#endif